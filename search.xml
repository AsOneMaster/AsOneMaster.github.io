<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>为什么代码中实例化结构体时大多要返回结构体指针 而不是结构体值</title>
    <url>/2022/08/17/go2/</url>
    <content><![CDATA[<p>在学习 go 语言项目时，遇到这样一个问题：</p>
<p>通过struct结构体作为一个model，数据绑定等操作都是返回一个结构体指针，那么返回一个结构体变量，或者返回一个结构体指针，他们的区别是什么？</p>
<p>因为二者都可以让我们生成我们所需要的结构体，<strong>那为什么还要去使用返回结构体指针呢</strong>？</p>
<p>对于此疑问，我做了如下实验</p>
<span id="more"></span>

<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token comment">// TableFile : 文件表结构体</span>
<span class="token keyword">type</span> TableFile <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	FileHash <span class="token builtin">string</span>
	FileName <span class="token builtin">string</span>
	FileSize <span class="token builtin">string</span>
	FileAddr <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// GetFileMeta1  从mysql获取文件元信息</span>
<span class="token keyword">func</span> <span class="token function">GetFileMeta1</span><span class="token punctuation">(</span>filehash1 <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>TableFile <span class="token punctuation">&#123;</span>

	tfile1 <span class="token operator">:=</span> TableFile<span class="token punctuation">&#123;</span>FileHash<span class="token punctuation">:</span> filehash1<span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"GetFileMeta1函数内：%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tfile1<span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>tfile1
<span class="token punctuation">&#125;</span>

<span class="token comment">// GetFileMeta2  从mysql获取文件元信息</span>
<span class="token keyword">func</span> <span class="token function">GetFileMeta2</span><span class="token punctuation">(</span>filehash1 <span class="token builtin">string</span><span class="token punctuation">)</span> TableFile <span class="token punctuation">&#123;</span>

	tfile2 <span class="token operator">:=</span> TableFile<span class="token punctuation">&#123;</span>FileHash<span class="token punctuation">:</span> filehash1<span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"GetFileMeta2函数内：%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tfile2<span class="token punctuation">)</span>
	<span class="token keyword">return</span> tfile2
<span class="token punctuation">&#125;</span>


<span class="token comment">// GetFileMeta3 从mysql获取文件元信息</span>
<span class="token keyword">func</span> <span class="token function">GetFileMeta3</span><span class="token punctuation">(</span>filehash1 <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>tfile3 TableFile<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	tfile3 <span class="token operator">=</span> TableFile<span class="token punctuation">&#123;</span>FileHash<span class="token punctuation">:</span> filehash1<span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"GetFileMeta3函数内：%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tfile3<span class="token punctuation">)</span>
	<span class="token keyword">return</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	t1 <span class="token operator">:=</span> <span class="token function">GetFileMeta1</span><span class="token punctuation">(</span><span class="token string">"1111"</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"GetFileMeta1  函数外%p\n"</span><span class="token punctuation">,</span> t1<span class="token punctuation">)</span>
	t2 <span class="token operator">:=</span> <span class="token function">GetFileMeta2</span><span class="token punctuation">(</span><span class="token string">"1111"</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"GetFileMeta2  函数外%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>t2<span class="token punctuation">)</span>
	t3 <span class="token operator">:=</span> <span class="token function">GetFileMeta3</span><span class="token punctuation">(</span><span class="token string">"1111"</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"GetFileMeta3  函数外%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>t3<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span class="token comment">//GetFileMeta1函数内：0xc00005a040</span>
<span class="token comment">//GetFileMeta1  函数外0xc00005a040</span>

<span class="token comment">//GetFileMeta2函数内：0xc00005a0c0</span>
<span class="token comment">//GetFileMeta2  函数外0xc00005a080</span>

<span class="token comment">//GetFileMeta3函数内：0xc00005a140</span>
<span class="token comment">//GetFileMeta3  函数外0xc00005a100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里可以发现：</p>
<ul>
<li>使用指针结构体只分配了一次内存</li>
<li>使用结构体值却分配了两次</li>
</ul>
<p>由于go是值拷贝模式，指针拷贝地址，没有分配多余内存；值拷贝数值，新的变量会重新分配地址给数值。</p>
<p>这一点了解了，可是我仍然不知道指针的性能提升在那里，虽然指针只分配了一次地址空间，可是该空间会分配在堆上发生内存逃逸，影响程序性能；</p>
<p>值空间虽然分配了两次空间，但函数内变量空间分配在栈上，函数结束，系统内核会自动销毁，不影响性能，？难道是多次分配调度内存空间，影响更大？</p>
<p>返回结构体值与结构体指针性能问题:</p>
<p><strong>传值 VS 传指针</strong>： 传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。</p>
<p> 一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能</p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言基础1——make和new</title>
    <url>/2022/08/17/go1/</url>
    <content><![CDATA[<h5 id="golang中make和new的区别"><a href="#golang中make和new的区别" class="headerlink" title="golang中make和new的区别"></a>golang中make和new的区别</h5><p>共同点：都是给变量分配内存；<br>不同点：</p>
<ol>
<li><p>返回类型不同： new创建返回指针，指向分配类型的指针，分配的空间置为零，该类型的零值；make返回变量本身，分配空间后会进行初始；</p>
</li>
<li><p>分配类型：new可以为任意类型进行分配；make只能为slice，map，chan引用类型数据进行分配空间。</p>
</li>
</ol>
<h5 id="数组和切片的区别"><a href="#数组和切片的区别" class="headerlink" title="数组和切片的区别"></a>数组和切片的区别</h5><p>共同点：都是通过下标访问，并且都有容量长度；</p>
<p>不同点：</p>
<ol>
<li>定义方式不同：数组必须指定大小，定义后不能增加容量和长度；切片不用，定义后切片数据增多，会自动扩容（当原切片长度小于1024时，新切片的容量会直接翻倍；超过1024会反复地增加25%，直到新容量超过所需要的容量）；</li>
<li>类型不同：数值为值类型；切片为引用类型，每个切片底层引用一个数组，所以切片扩容后，便会指向一个新的底层数组，内存地址跟着改变。</li>
</ol>
<span id="more"></span>

<h5 id="for-range-的时候它的地址会发生变化么？"><a href="#for-range-的时候它的地址会发生变化么？" class="headerlink" title="for range 的时候它的地址会发生变化么？"></a>for range 的时候它的地址会发生变化么？</h5><p>在 for a,b := range c 遍历中，a,b只会存一份地址，循环后会重新赋值，内存地址不变；因此for中创建协程后不要传入a或b的地址，可以再循环中通过创建临时变量解决。</p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>切片</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言基础2——map相关</title>
    <url>/2022/08/18/go3/</url>
    <content><![CDATA[<h5 id="map-中删除一个-key，它的内存会释放么？"><a href="#map-中删除一个-key，它的内存会释放么？" class="headerlink" title="map 中删除一个 key，它的内存会释放么？"></a>map 中删除一个 key，它的内存会释放么？</h5><p>两种情况：</p>
<ol>
<li>value元素为值类型时，不会释放内存</li>
<li>value元素为引用类型时，会释放内存，释放该元素类型所占内存</li>
</ol>
<p>当map置为nil时，内存被回收 [（go垃圾回收)](<a href="https://www.bilibili.com/video/BV1B34y1h73h?spm_id_from=333.337.search-card.all.click">[Go面试]Go GC实现原理?_哔哩哔哩_bilibili</a>)</p>
<span id="more"></span>

<h5 id="map-使用注意的点，是否并发安全？"><a href="#map-使用注意的点，是否并发安全？" class="headerlink" title="map 使用注意的点，是否并发安全？"></a>map 使用注意的点，是否并发安全？</h5><ol>
<li>一定要先初始化，否则panic</li>
<li>map类型(引用类型)是容易发生并发访问问题的。不注意就容易发生程序运行时并发读写导致的panic。 Go语言内建的map对象不是线程安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic。</li>
</ol>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言基础3——GC相关</title>
    <url>/2022/08/18/go4/</url>
    <content><![CDATA[<h5 id="什么是GC"><a href="#什么是GC" class="headerlink" title="什么是GC"></a>什么是GC</h5><p>垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。</p>
<p>堆<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>上分配的数据对象，不会再使用时，不会自动释放内存，就变成垃圾，在程序的运行过程中，如果不能及时清理，会导致越来越多的内存空间被浪费，导致系统性能下降。</p>
<p>因此需要<strong>内存回收</strong>，内存回收分为两种方式:</p>
<ol>
<li><p>手动释放占用内存空间</p>
<p>可能会出现的问题：<br><strong>悬挂指针：</strong> 释放的早了，后续对数据的访问就会出错，因为对应的内存空间可能已经清空，重新分配，甚至是归还给操作系统了。<br><strong>内存泄漏：</strong> 如果忘了释放，一直占用内存，导致内存泄漏。</p>
</li>
<li><p>自动内存回收</p>
<p>程序自动检测对象决定是否要回收其内存。</p>
<p><strong>核心思想：</strong>程序中用得到的数据，一定是可以从栈或数据段这些根节点追踪得到的数据，追踪不到的数据，肯定用不到，也就是垃圾。</p>
<span id="more"></span></li>
</ol>
<h5 id="go-gc-是怎么实现的？"><a href="#go-gc-是怎么实现的？" class="headerlink" title="go gc 是怎么实现的？"></a>go gc 是怎么实现的？</h5><hr>
<p>一次完整的垃圾回收会分为四个阶段，分别是标记准备、标记开始、标记终止、清理：</p>
<ol>
<li><strong>标记准备（Mark Setup）</strong>：打开写屏障（Write Barrier），需 STW（stop the world)</li>
<li><strong>标记开始（Marking）</strong>：使用三色标记法并发标记 ，与用户程序并发执行</li>
<li><strong>标记终止（Mark Termination</strong>）：对触发写屏障的对象进行重新扫描标记，关闭写屏障（Write Barrier），需 STW（stop the world)</li>
<li><strong>清理（Sweeping）</strong>：将需要回收的内存归还到堆中，将过多的内存归还给操作系统，与用户程序并发执行</li>
</ol>
<hr>
<ol>
<li><p><strong>GC机制随着golang版本变化如何变化的？</strong></p>
<p>go 1.3 之前采用<strong>标记清除法</strong>，需要<strong>STW</strong><br>go 1.5 采用<strong>三色标记法</strong>，插入<strong>写屏障机制</strong>（只在堆内存中生效），最后仍需对栈内存进行STW<br>go 1.8 采用混合写屏障机制**，屏障限制只在堆内存中生效。避免了最后节点对栈进行STW的问题，提升了GC效率</p>
</li>
<li><p>一个概念：<strong>STW</strong>：stop the word，指程序执行过程中，中断暂停程序逻辑，专门去进行<a href="https://so.csdn.net/so/search?q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&spm=1001.2101.3001.7020">垃圾回收</a>。（STW<strong>目的是为了防止GC扫描时内存变化引起的混乱</strong>）</p>
</li>
<li><p><strong>标记清除法</strong></p>
<p>从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。</p>
<ul>
<li>开启STW，</li>
<li>从根节点出发，标记所有可达对象 </li>
<li>停止STW，然后回收所有未标记的对象。</li>
<li>优点：解决了引用计数的缺点。</li>
<li>缺点：需要 STW，暂时停掉程序运行。</li>
</ul>
</li>
<li><p><strong>三色标记法【改进的标记清除法】+写屏障机制的流程</strong></p>
</li>
</ol>
<p>三色标记法是对标记阶段的改进，原理如下：</p>
<ul>
<li>初始状态所有对象都是白色。</li>
<li>从root根出发扫描所有根对象（下图a,b），将他们引用的对象标记为灰色（图中A，B）</li>
</ul>
<blockquote>
<p>那么什么是root呢？ 看了很多文章都没解释这这个概念，在这儿说明下：root区域主要是程序运行到当前时刻的栈、寄存器和全局变量。</p>
<p><img src="/2022/08/18/go4/image-20220802113108020.png" alt="image-20220802113108020"></p>
</blockquote>
<ul>
<li><p>遍历灰色对象，将灰色对象引用的对象由白色  也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。</p>
</li>
<li><p>循环步骤3，直到灰色对象全部变黑色。重复以上操作</p>
<blockquote>
<p>其中通过<strong>写屏障</strong>(write-barrier)【<strong>写屏障就是让goroutine与GC同时运行的手段，大大减少STW的时间</strong>，开启后指针传递时会把指针标记，本轮不回收，下轮GC时回收】检测对象有变化；还有一个<strong>辅助GC</strong>(mutator assist)机制【<strong>为防止内存分配过快，GC过程中，辅助GC线程并发运行，协助GC做一部分工作</strong>，先做一部分标记工作】，</p>
</blockquote>
</li>
<li><p>收集所有白色对象（垃圾）。</p>
</li>
</ul>
<p><strong>插入写屏障</strong></p>
<p>对象被引用时触发的机制（只在堆内存中生效）：赋值器这一行为通知给并发执行的回收器，被引用的对象标记为灰色</p>
<p>缺点：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活</p>
<p><strong>删除写屏障</strong></p>
<p>对象被删除时触发的机制（只在堆内存中生效）：赋值器将这一行为通知给并发执行的回收器，被删除的对象，如果自身为灰色或者白色，那么标记为灰色</p>
<p>缺点：一个对象的引用被删除后，即使没有其他存活的对象引用它，它仍然会活到下一轮，会产生很大冗余扫描成本，且降低了回收精度</p>
<p><strong>混合写屏障</strong></p>
<p>GC没有混合写屏障前，一直是插入写屏障；混合写屏障是插入写屏障 + 删除写屏障，写屏障只应用在堆上应用，栈上不启用（栈上启用成本很高）</p>
<ul>
<li>GC开始将栈上的对象全部扫描并标记为黑色。</li>
<li>GC期间，任何在栈上创建的新对象，均为黑色。</li>
<li>被删除的对象标记为灰色。</li>
<li>被添加的对象标记为灰色。</li>
</ul>
<h5 id="GC-的触发时机"><a href="#GC-的触发时机" class="headerlink" title="GC 的触发时机"></a>GC 的触发时机</h5><p><strong>主动触发</strong>：</p>
<ul>
<li>调用 runtime.GC() 方法，触发 GC</li>
</ul>
<p><strong>被动触发：</strong></p>
<ul>
<li>定时触发，该触发条件由 <code>runtime.forcegcperiod</code> 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，触发 GC</li>
<li>根据内存分配阈值触发，该触发条件由环境变量GOGC控制，默认值为100（100%），当前堆内存占用是上次GC结束后占用内存的2倍时，触发GC</li>
</ul>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>GC垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言基础4——Channel相关</title>
    <url>/2022/08/18/go5/</url>
    <content><![CDATA[<h5 id="channel-是否线程安全？锁用在什么地方？"><a href="#channel-是否线程安全？锁用在什么地方？" class="headerlink" title="channel 是否线程安全？锁用在什么地方？"></a>channel 是否线程安全？锁用在什么地方？</h5><blockquote>
<p>Golang的Channel,发送一个数据到Channel 和 从Channel接收一个数据都是原子性的。</p>
<p>如果把线程安全定义为允许多个goroutine同时去读写，那么golang 的channel 是线程安全的，因为channel底层数据结构中是带有lock的，不需要在并发读写同一个channe时再加锁。</p>
<p>而且Go的设计思想就是：不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁（共享内存通信），后者就是Channel。</p>
<p>也就是说，设计Channel的主要目的就是在多任务间传递数据的，这当然是安全的</p>
</blockquote>
<h5 id="go-channel-的底层实现原理-（数据结构）"><a href="#go-channel-的底层实现原理-（数据结构）" class="headerlink" title="go channel 的底层实现原理 （数据结构）"></a>go channel 的底层实现原理 （数据结构）</h5><p>总结hchan结构体的主要组成部分有四个：</p>
<ul>
<li>用来保存goroutine之间传递数据的循环数组：buf</li>
<li>用来记录此循环数组当前发送或接收数据的下标值：sendx（发送队列）和recvx（接受队列）</li>
<li>用于保存向该chan发送和从该chan接收数据被阻塞的goroutine队列： sendq 和 recvq</li>
<li>保证channel写入和读取数据时线程安全的锁：lock</li>
</ul>
<span id="more"></span>

<h5 id="go-channel为什么设计成线程安全？"><a href="#go-channel为什么设计成线程安全？" class="headerlink" title="go channel为什么设计成线程安全？"></a>go channel为什么设计成线程安全？</h5><p>不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全</p>
<h5 id="如何实现线程安全的？"><a href="#如何实现线程安全的？" class="headerlink" title="如何实现线程安全的？"></a>如何实现线程安全的？</h5><p>channel的底层实现中，hchan结构体中采用Mutex（互斥）锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据</p>
<h5 id="nil、关闭的-channel、有数据的-channel，再进行读、写、关闭会怎么样？"><a href="#nil、关闭的-channel、有数据的-channel，再进行读、写、关闭会怎么样？" class="headerlink" title="nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？"></a>nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？</h5><ol>
<li>读写值 nil 管道会永久阻塞 </li>
<li>关闭的管道读数据仍然可以读数据 </li>
<li>往关闭的管道写数据会 panic</li>
<li>关闭为 nil 的管道会 panic </li>
<li>关闭已经关闭的管道 panic</li>
</ol>
<p><strong>总结：</strong>对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。如果我们试图关闭一个已经关闭了的通道，也会引发 panic。</p>
<p><strong>使用场景：</strong> 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步</p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>Channel</tag>
      </tags>
  </entry>
  <entry>
    <title>golang学习路线，所需知识</title>
    <url>/2022/08/17/golangStudy/</url>
    <content><![CDATA[<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="1-操作系统"><a href="#1-操作系统" class="headerlink" title="1. 操作系统"></a>1. 操作系统</h3><ul>
<li><h5 id="了解进程、线程、协程的区别"><a href="#了解进程、线程、协程的区别" class="headerlink" title="了解进程、线程、协程的区别"></a>了解进程、线程、协程的区别</h5></li>
<li><h5 id="了解进程间常用的通信方式"><a href="#了解进程间常用的通信方式" class="headerlink" title="了解进程间常用的通信方式"></a>了解进程间常用的通信方式</h5><ol>
<li>管道</li>
<li>命名管道（FIFO）</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
<li>套接字（Socket）</li>
</ol>
</li>
<li><h5 id="了解5种网络IO模型"><a href="#了解5种网络IO模型" class="headerlink" title="了解5种网络IO模型"></a>了解5种网络IO模型</h5><ol>
<li>阻塞 IO（blocking IO）</li>
<li>非阻塞 IO（non-blocking IO）</li>
<li>多路复用 IO（IO multiplexing）</li>
<li>异步 IO（Asynchronous I/O）</li>
<li>信号驱动 IO（signal driven I/O， SIGIO）</li>
</ol>
<span id="more"></span></li>
<li><h5 id="了解并发与并行的区别"><a href="#了解并发与并行的区别" class="headerlink" title="了解并发与并行的区别"></a>了解并发与并行的区别</h5><ol>
<li>并发是指一个处理器同时处理多个任务。</li>
<li>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。</li>
<li>并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。</li>
<li>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，</li>
<li>并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</li>
</ol>
</li>
<li><h5 id="了解同步与异步的区别"><a href="#了解同步与异步的区别" class="headerlink" title="了解同步与异步的区别"></a>了解同步与异步的区别</h5><ol>
<li>同步：同步是指一个进程在执行某个请求的时候，如果该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去。</li>
<li>异步：异步是指进程不需要一直等待下去，而是继续执行下面的操作，不管其他进程的状态，当有信息返回的时候会通知进程进行处理，这样就可以提高执行的效率了，即异步是我们发出的一个请求，该请求会在后台自动发出并获取数据，然后对数据进行处理，在此过程中，我们可以继续做其他操作，不管它怎么发出请求，不关心它怎么处理数据。</li>
<li>以上总结起来，通俗地讲，也就是说，同步需要按部就班地走完一整个流程，完成一整个动作，打个比方：同步的时候，你在写程序，然后你妈妈叫你马上拖地，你就必须停止写程序然后拖地，没法同时进行。而异步则不需要按部就班，可以在等待那个动作的时候同时做别的动作，</li>
</ol>
</li>
<li><h5 id="了解阻塞与非阻塞的区别"><a href="#了解阻塞与非阻塞的区别" class="headerlink" title="了解阻塞与非阻塞的区别"></a>了解阻塞与非阻塞的区别</h5></li>
<li><h5 id="了解常见缓存淘汰算法："><a href="#了解常见缓存淘汰算法：" class="headerlink" title="了解常见缓存淘汰算法："></a>了解常见缓存淘汰算法：</h5><ol>
<li>LRU（Least Recently Used）最近最少使用算法 </li>
<li>LFU（Least Frequently Used）最近频次最少算法 </li>
<li>FIFO（First In First Out）先入先出算法 </li>
<li>ARC（Adjustable Replacement Cache）自适应缓存替换算法</li>
</ol>
</li>
</ul>
<h3 id="2-计算机网络"><a href="#2-计算机网络" class="headerlink" title="2. 计算机网络"></a>2. 计算机网络</h3><ul>
<li><h5 id="了解网络协议"><a href="#了解网络协议" class="headerlink" title="了解网络协议"></a>了解网络协议</h5></li>
<li><h5 id="了解序列化协议"><a href="#了解序列化协议" class="headerlink" title="了解序列化协议"></a>了解序列化协议</h5></li>
<li><h5 id="了解七层体系结构"><a href="#了解七层体系结构" class="headerlink" title="了解七层体系结构"></a>了解七层体系结构</h5></li>
<li><h5 id="了解四层体系结构"><a href="#了解四层体系结构" class="headerlink" title="了解四层体系结构"></a>了解四层体系结构</h5></li>
</ul>
<h3 id="3-计算机组成原理（冯诺依曼体系）-了解"><a href="#3-计算机组成原理（冯诺依曼体系）-了解" class="headerlink" title="3. 计算机组成原理（冯诺依曼体系）[了解]"></a>3. 计算机组成原理（冯诺依曼体系）[了解]</h3><h3 id="4-数据结构与算法"><a href="#4-数据结构与算法" class="headerlink" title="4. 数据结构与算法"></a>4. 数据结构与算法</h3><ul>
<li><h5 id="了解时间-空间复杂度"><a href="#了解时间-空间复杂度" class="headerlink" title="了解时间/空间复杂度"></a>了解时间/空间复杂度</h5></li>
<li><h5 id="熟悉常用数据结构"><a href="#熟悉常用数据结构" class="headerlink" title="熟悉常用数据结构"></a>熟悉常用数据结构</h5><p>字符串<br>数组<br>链表<br>队列<br>二叉树<br>栈<br>堆</p>
</li>
<li><h5 id="熟悉常用算法"><a href="#熟悉常用算法" class="headerlink" title="熟悉常用算法"></a>熟悉常用算法</h5><p>双指针<br>左右指针<br>排序<br>二叉查找<br>递归<br>回溯<br>贪心<br>动态规划</p>
</li>
</ul>
<h3 id="5-互联网（Internet）"><a href="#5-互联网（Internet）" class="headerlink" title="5. 互联网（Internet）"></a>5. 互联网（Internet）</h3><ul>
<li><h5 id="互联网是如何工作的"><a href="#互联网是如何工作的" class="headerlink" title="互联网是如何工作的"></a>互联网是如何工作的</h5></li>
<li><h5 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h5></li>
<li><h5 id="浏览器以及浏览器如何运作"><a href="#浏览器以及浏览器如何运作" class="headerlink" title="浏览器以及浏览器如何运作"></a>浏览器以及浏览器如何运作</h5></li>
<li><h5 id="域名是什么"><a href="#域名是什么" class="headerlink" title="域名是什么"></a>域名是什么</h5></li>
<li><h5 id="hosting是什么"><a href="#hosting是什么" class="headerlink" title="hosting是什么"></a>hosting是什么</h5></li>
</ul>
<h3 id="6-数据库"><a href="#6-数据库" class="headerlink" title="6. 数据库"></a>6. 数据库</h3><ul>
<li><h5 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h5><p>Mysql</p>
</li>
<li><h5 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h5><p>Redis</p>
</li>
</ul>
<h2 id="Golang编程基础"><a href="#Golang编程基础" class="headerlink" title="Golang编程基础"></a>Golang编程基础</h2><ul>
<li>字符串</li>
<li>常量</li>
<li>变量</li>
<li>类型</li>
<li>操作符</li>
<li>表达式</li>
<li>语句</li>
<li>错误处理</li>
</ul>
<h3 id="1-代码组织"><a href="#1-代码组织" class="headerlink" title="1. 代码组织"></a>1. 代码组织</h3><h3 id="2-标准库"><a href="#2-标准库" class="headerlink" title="2. 标准库"></a>2. 标准库</h3><ul>
<li><h5 id="功能性"><a href="#功能性" class="headerlink" title="功能性"></a>功能性</h5><p>net<br>errors<br>os<br>sync<br>time</p>
</li>
<li><h5 id="输入输出型"><a href="#输入输出型" class="headerlink" title="输入输出型"></a>输入输出型</h5><p>io<br>fmt<br>log</p>
</li>
</ul>
<h3 id="3-版本控制"><a href="#3-版本控制" class="headerlink" title="3. 版本控制"></a>3. 版本控制</h3><ul>
<li><h5 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h5></li>
</ul>
<h2 id="Go编程进阶"><a href="#Go编程进阶" class="headerlink" title="Go编程进阶"></a>Go编程进阶</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li><strong>map</strong></li>
<li><strong>channel</strong></li>
<li><strong>goroutine</strong></li>
<li><strong>slice</strong></li>
<li><strong>runtime</strong></li>
</ul>
<h3 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h3><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><h3 id="CGO"><a href="#CGO" class="headerlink" title="CGO"></a>CGO</h3><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li><strong>单元测试</strong></li>
<li><strong>压力测试</strong></li>
<li><strong>覆盖测试</strong></li>
<li><strong>性能测试</strong></li>
</ul>
<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><ul>
<li><p><strong>goroutine调度</strong></p>
</li>
<li><p><strong>channel调度</strong></p>
</li>
<li><p><strong>锁</strong></p>
</li>
<li><p><strong>waitGroup</strong></p>
</li>
<li><p><strong>context</strong></p>
</li>
<li><p><strong>sync</strong></p>
</li>
<li><p><strong>atomic</strong></p>
</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><img src="/2022/08/17/golangStudy/image-20220805143702043.png" alt="image-20220805143702043"></p>
<h2 id="数据结构与算法（熟练掌握）"><a href="#数据结构与算法（熟练掌握）" class="headerlink" title="数据结构与算法（熟练掌握）"></a>数据结构与算法（熟练掌握）</h2><h2 id="计算机原理与网络"><a href="#计算机原理与网络" class="headerlink" title="计算机原理与网络"></a>计算机原理与网络</h2><p><img src="/2022/08/17/golangStudy/image-20220805143827008.png" alt="image-20220805143827008"></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><img src="/2022/08/17/golangStudy/image-20220805143839926.png" alt="image-20220805143839926"></p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="/2022/08/17/golangStudy/image-20220805143854645.png" alt="image-20220805143854645"></p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><img src="/2022/08/17/golangStudy/image-20220805143913401.png" alt="image-20220805143913401"></p>
<p><img src="/2022/08/17/golangStudy/image-20220805143922828.png" alt="image-20220805143922828"></p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><img src="/2022/08/17/golangStudy/image-20220805143950466.png" alt="image-20220805143950466"></p>
<h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p><img src="/2022/08/17/golangStudy/image-20220805144025693.png" alt="image-20220805144025693"></p>
<h3 id="Web框架"><a href="#Web框架" class="headerlink" title="Web框架"></a>Web框架</h3><p><img src="/2022/08/17/golangStudy/image-20220805144030069.png" alt="image-20220805144030069"></p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p><img src="/2022/08/17/golangStudy/image-20220805144116432.png" alt="image-20220805144116432"></p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>golang学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么InnoDB存储引擎选择使用B+tree索引结构?</title>
    <url>/2022/08/18/mysql2/</url>
    <content><![CDATA[<p>由于B+tree所有数据都在叶子节点，上层节点仅仅起到索引结构，相对于二叉树，层级更少，搜索效率更高！</p>
<p><strong>如图：</strong></p>
<p><img src="/2022/08/18/mysql2/image-20220818153400906.png" alt="image-20220818153400906"></p>
<p>其他结构讲解，链接—-<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68&vd_source=5d110a858f2be0cfcf644f3a61ef01c8">11. 进阶-索引-结构-Btree_哔哩哔哩_bilibili</a></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>Mysql存储引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶1——Mysql存储引擎与索引相关</title>
    <url>/2022/08/18/mysql1/</url>
    <content><![CDATA[<h3 id="MySql存储引擎"><a href="#MySql存储引擎" class="headerlink" title="MySql存储引擎"></a>MySql存储引擎</h3><h4 id="Mysql体系结构"><a href="#Mysql体系结构" class="headerlink" title="Mysql体系结构"></a>Mysql体系结构</h4><ul>
<li>连接层</li>
<li>服务层</li>
<li>引擎层</li>
<li>存储层</li>
</ul>
<h4 id="什么是存储引擎"><a href="#什么是存储引擎" class="headerlink" title="什么是存储引擎"></a>什么是存储引擎</h4><blockquote>
<p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。</p>
</blockquote>
<span id="more"></span>

<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><ul>
<li><p>InnoDB</p>
<pre><code>➢介绍：
      InnoDB是一种兼顾高可靠性和高性能的通用存储引擎,在MySQL 5.5之后, InnoDB是默认的MySQL存储引擎。
  ➢特点：
      DML操作遵循ACID模型，支持事务;
      行级锁，提高并发访问性能; 
      支持外键FOREIGN KEY约束,保证数据的完整性和正确性;
</code></pre>
<p>​    ➢文件：</p>
<p>​        xxx.ibd: xxx代表的是表名, innoDB引擎的每张表都会对应这样一个表空间文件, 存储该表的表结构(frm、 sdi) 、数据和索引。<br>​        参数: innpdb_ file_ per_ table    </p>
<p>​    ➢逻辑存储结构：</p>
<p>​        TableSpece:     表空间</p>
<p>​        |</p>
<p>​        segment:          段<br>​        |</p>
<p>​        Extent:I             区[1M—一个区可以有64个页]<br>​        |</p>
<p>​        Page:                 页[16K]<br>​        |</p>
<p>​        Row:                  行</p>
</li>
</ul>
<p><img src="/2022/08/18/mysql1/image-20220818151444624.png" alt="image-20220818151444624"></p>
<ul>
<li><p>MyISAM</p>
<pre><code>        ➢介绍
              MyISAM是MySQL早期的默认存储引擎。
          ➢特点
              不支持事务,不支持外键
              支持表锁，不支持行锁
              访问速度快
          ➢文件
              xxx.sdi:存储表结构信息
              XXX.MYD:存储数据
              XXX.MYI:存储索引
</code></pre>
</li>
<li><p>Memory</p>
<pre><code>        ➢介绍
              Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。
          ➢特点
              内存存放
              hash索引( 默认)
          ➢文件
              xxx.sdi:存储表结构信息
</code></pre>
</li>
</ul>
<p><strong>MySql存储引擎特点总结：</strong></p>
<p><img src="/2022/08/18/mysql1/image-20220818151922258.png" alt="image-20220818151922258"></p>
<h4 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h4><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<p>​            ➢InnoDB ：是Mysql的默认存储引擎， 支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的-致</p>
<p>​                                性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储 引擎是比较合适的选择。</p>
<p>​            ➢MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那</p>
<p>​                                么选择这个存储引擎是非常合适的。<strong>（现如今被NOSQL-MongoDB替代）</strong></p>
<p>​            ➢MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表</p>
<p>​                                无法缓存在内存中，而且无法保障数据的安全性。<strong>（现如今被NOSQL-Redis替代）</strong></p>
<h3 id="Mysql索引（存储引擎层）"><a href="#Mysql索引（存储引擎层）" class="headerlink" title="Mysql索引（存储引擎层）"></a>Mysql索引（存储引擎层）</h3><h4 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h4><blockquote>
<p>索引(index)是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级的查找算法，这种数据结构就是索引。</p>
<p><strong>简单的说，索引是一种数据结构，一种实现高级查找算法的数据结构。</strong></p>
</blockquote>
<h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构,主要包含以下几种:</p>
<ul>
<li>B+Tree    ——    最常见的索引类型，大部分引擎都支持B+树索引</li>
<li>Hash       ——    底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</li>
<li>R-tree(空间索引)       ——  空间索引是MyISAM弓|擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</li>
<li>Full-text(全文索引)   ——  是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene，Solr，ES</li>
</ul>
<h4 id="索引结构与对应支持引擎"><a href="#索引结构与对应支持引擎" class="headerlink" title="索引结构与对应支持引擎"></a>索引结构与对应支持引擎</h4><p><img src="/2022/08/18/mysql1/image-20220818150013108.png" alt="image-20220818150013108"></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>Mysql存储引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础1</title>
    <url>/2022/08/19/redis1/</url>
    <content><![CDATA[<h1 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h1><blockquote>
<p> Redis是基于内存运行的高性能 K-V 数据库</p>
</blockquote>
<h1 id="Redis存储位置"><a href="#Redis存储位置" class="headerlink" title="Redis存储位置"></a>Redis存储位置</h1><blockquote>
<p> 内存中，所以效率高 </p>
</blockquote>
<h1 id="Redis的五种数据结构"><a href="#Redis的五种数据结构" class="headerlink" title="Redis的五种数据结构"></a>Redis的五种数据结构</h1><ul>
<li>String：Redis最基本的数据类型，一个键对应一个值，一个键值最大存储512MB</li>
<li>set：是String字符串类型的无序集合，也不可重复</li>
<li>zset：是String类型的有序集合，也不可重复。有序集合中的每个元素都需要指定一个分数，根据分数对元素进行升序排序</li>
</ul>
<span id="more"></span>

<ul>
<li>hash：hash是一个键值对的集合，是一个String类型的field和value的映射表，适合用于存储对象</li>
<li>list：是redis的简单的字符串列表，按插入顺序排序</li>
</ul>
<h1 id="Redis应用场景（可以用来做什么）"><a href="#Redis应用场景（可以用来做什么）" class="headerlink" title="Redis应用场景（可以用来做什么）"></a>Redis应用场景（可以用来做什么）</h1><blockquote>
<p> 可用于缓存，事件发布或订阅，高速队列等场景  众多语言都支持Redis，因为Redis交换数据快，在服务器中常用来存储一些需要频繁调取的数据，节省内存开销，也极大的提升了速度。 将一些热点数据存储到Redis中，要用的时候，直接从内存取，极大的提高了速度和节约了服务器的开销。  </p>
</blockquote>
<ul>
<li>会话缓存（最常用）</li>
<li>消息队列（支付）</li>
<li>活动排行榜或计数</li>
<li>发布，订阅消息（消息通知）</li>
<li>商品列表，评论列表</li>
</ul>
<h1 id="为什么使用Redis"><a href="#为什么使用Redis" class="headerlink" title="为什么使用Redis"></a>为什么使用Redis</h1><ul>
<li>完全基于内存，数据存在内存中，绝大部分请求是纯粹的内存操作，非常快速，跟传统的磁盘文件数据存储相比，避免了通过磁盘IO读取到内存这部分的开销。</li>
<li>数据结构简单，对数据操作也简单。Redis中的数据结构是专门进行设计的，每种数据结构都有一种或多种数据结构来支持。Redis正是依赖这些灵活的数据结构，来提升读取和写入的性能。</li>
<li>采用单线程，省去了很多上下文切换的时间以及CPU消耗，不存在竞争条件，不用去考虑各种锁的问题，不存在加锁释放锁操作，也不会出现死锁而导致的性能消耗。</li>
<li>使用基于IO多路复用机制的线程模型，可以处理并发的链接。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言的并发机制</title>
    <url>/2022/08/19/goRoutine/</url>
    <content><![CDATA[<h2 id="go语言并发原理"><a href="#go语言并发原理" class="headerlink" title="go语言并发原理"></a>go语言并发原理</h2><blockquote>
<p>Go不推荐用共享内存的方式传递数据，而推荐使用channel(或称“通道” )。channel主要用来在多个goroutine之间传递数据，并且还</p>
<p>会保证整个过程的并发安全性。不过，作为可选方法，Go依然提供了一些传统的同步方法 (比如互斥量、 条件变量等)。</p>
<p><strong>Go的并发机制</strong>指的是用于支撑goroutine 和channel的底层原理，说到这个就不得不提go语言的调度模型，GMP。</p>
</blockquote>
<h3 id="GMP调度模型"><a href="#GMP调度模型" class="headerlink" title="GMP调度模型"></a>GMP调度模型</h3><p>说起Go的线程实现模型,有3个必知的核心元素,它们支撑起了这个模型的主框架，<br>简要说明如下：</p>
<ul>
<li>M: machine的缩写。一个M代表一个内核线程，或称“工作线程”。</li>
<li>P: processor的缩写。一个P代表执行一个Go代码片段所必需的资源(或称“上下文环境”)。</li>
<li>G: goroutine的缩写。一个G代表一 个Go代码片段。前者是对后者的一种封装。</li>
</ul>
<p>.未完待续~~~</p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine(协程)和线程是什么关系，goroutine是如何调度的？</title>
    <url>/2022/08/20/go6/</url>
    <content><![CDATA[<blockquote>
<p>（上级问题并发  问题逻辑-  并发机制-&gt;GMP-&gt;goroutine调度）</p>
</blockquote>
<h4 id="goroutine-协程-和线程"><a href="#goroutine-协程-和线程" class="headerlink" title="goroutine(协程)和线程"></a>goroutine(协程)和线程</h4><p>说线程之前，我们先说进程和线程的关系，</p>
<p>首先线程是进程的执行体，拥有一个执行入口，以及进程虚拟地址空间中分配的栈—包括用户栈和内核栈，操作系统会记录线程控制信息，</p>
<p>而线程会在获得cpu时间片信息后执行 ，cpu中栈指针、指令指针等寄存器都到切换到对应的线程；</p>
<p>而协程就是线程创建的执行体，其控制信息由线程记录，由于用户程序不能操作内核空间，所以只能给协程分配用户栈，而操作系统对这个信息一无所知。</p>
<p><strong>总结：</strong>协程是一种”用户态线程”。</p>
<h4 id="goroutine如何调度"><a href="#goroutine如何调度" class="headerlink" title="goroutine如何调度"></a>goroutine如何调度</h4><p>说到goroutine的调度就不得不提MPG（GMP）模型</p>
<ul>
<li>M: 线程</li>
<li>P: 执行go协程运行所必需的资源，关联本地可运行G的队列</li>
<li>G: go协程</li>
</ul>
<span id="more"></span>

<h4 id="G，M，P的个数"><a href="#G，M，P的个数" class="headerlink" title="G，M，P的个数"></a>G，M，P的个数</h4><ul>
<li>M 的数据默认启动的时候是 10000，内核很难支持这么多线程数，所以整个限制客户忽略，M 一般不做设置，设置好 P，M 一般都是要大于 P。</li>
<li>P 的数量一般建议是逻辑 CPU 数量的 2 倍。——使用<strong>runtime.GOMAXPROCS()</strong> 变量数一般是cpu核数的2倍，具体看性能分析。</li>
<li>G 的个数理论上是无限制的，但是受内存限制。</li>
</ul>
<p>一开始go创建时只有MG，多个M分担多个G的执行任务时（想象整体G是一个全局队列，多个M执行G时），就会因为频繁 加锁解锁（不能让其他线程执行到同一个G）而发生等待，影响并发性能。所以，使用P，p有一个本地队列，这样只要M关联到P，就可以直接运行队列中待执行的G，不用每次从全局队列中争抢了。</p>
<p>（注意一个问题：程序中主进程结束不管协程有没有运行完，都会结束，所以一般使用wg <strong>sync.WaitGroup</strong>  wg.Add()  go func(){    wg.Done}  wg.Wait()）</p>
<p><strong>总结GMP调度流程：</strong></p>
<ul>
<li>线程M想运行任务就需得获取 P，即与P关联。</li>
<li>然从 P 的本地队列(LRQ)获取 G</li>
<li>若LRQ中没有可运行的G，M 会尝试从全局队列(GRQ)拿一批G放到P的本地队列，</li>
<li>若全局队列也未找到可运行的G时候，M会随机从其他 P 的本地队列偷一半放到自己 P 的本地队列。</li>
<li>拿到可运行的G之后，M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li>
</ul>
<h4 id="Go如何有效控制Goroutine并发数量"><a href="#Go如何有效控制Goroutine并发数量" class="headerlink" title="Go如何有效控制Goroutine并发数量"></a>Go如何有效控制Goroutine并发数量</h4>]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>逃逸分析能做什么？如何进行逃逸分析？</title>
    <url>/2022/08/20/go7/</url>
    <content><![CDATA[<blockquote>
<p>（上级垃圾回收 问题逻辑- 垃圾回收-&gt;逃逸分析-&gt;内存逃逸）</p>
</blockquote>
<blockquote>
<p>逃逸分析是什么：编译器决定内存分配位置的方式，就称之为逃逸分析(escape analysis)。逃逸分析由编译器完成，作用于编译阶段。</p>
<p>逃逸分析能做什么：可以了解程序哪些内存在栈上，哪些在堆上，从而优化减少垃圾回收提升性能。</p>
<p>如何进行逃逸分析：go语言可以使用<strong>go build -gcflags ‘-m -N -l’</strong>  test.go 的方式 查看编译结果中的逃逸情况 在堆上（heap）的就发生了逃逸</p>
</blockquote>
<p> <strong>必然不会发生逃逸的情况：</strong></p>
<ol>
<li><p>指针被没有发生逃逸的变量引用</p>
</li>
<li><p>仅仅在函数被对变量进行取地址操作，没有将指针传出</p>
<span id="more"></span></li>
</ol>
<p> <strong>一定逃逸</strong></p>
<ol>
<li>构造函数new/make 返回的指针变量一定逃逸</li>
<li>被已经逃逸指针变量引用指针，一定发生逃逸</li>
<li>指针类型是slice，map,chan 引用指针一定发生逃逸</li>
</ol>
<p><strong>Maybe 逃逸</strong><br> 将指针作为入参传给别的函数，这里看指针在被传入函数的处理过程，如果发生上边三种情况会逃逸，否则不会</p>
<p><strong>传值 VS 传指针</strong>： 传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。</p>
<p> 一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能</p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>内存逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言基础5--切片与数组相关</title>
    <url>/2022/08/22/go8/</url>
    <content><![CDATA[<h4 id="slice-和-array的区别？（下级问题-gt-slice底层与扩容机制）"><a href="#slice-和-array的区别？（下级问题-gt-slice底层与扩容机制）" class="headerlink" title="slice 和 array的区别？（下级问题-&gt;slice底层与扩容机制）"></a>slice 和 array的区别？（下级问题-&gt;slice底层与扩容机制）</h4><ul>
<li>数组的零值是元素类型的零值，切片的零值是 nil；</li>
<li>数组是固定长度，切片是可变长度；</li>
<li>数组是值类型，切片是引用类型。</li>
</ul>
<h4 id="slice的底层实现"><a href="#slice的底层实现" class="headerlink" title="slice的底层实现"></a>slice的底层实现</h4><blockquote>
<p>slice 底层 是有 3 个字段的数据结构分为：</p>
<ul>
<li>array 数组</li>
<li>len 长度</li>
<li>cap 容量</li>
</ul>
</blockquote>
<p>指针指向数组的第一个该 slice 可访问的元素，这个元素并不一定是底层数组的第一个元素，长度是指 slice 中元素的个数，它不能超过 slice 的容量。</p>
<p>容量的大小通常是从 slice 底层数组的元素个数，什么意思呢举例：</p>
<p>arr：=[]int{1,2,3,4} slice:=arr[1:3] —（即：{2，3，4}） slice的长度为3 容量为4（{1，2，3，4}为底层数组）</p>
<p>Go 的内置函数 len 和 cap 用来返回 slice 的长度和容量。</p>
<span id="more"></span>

<h4 id="slice扩容机制"><a href="#slice扩容机制" class="headerlink" title="slice扩容机制"></a>slice扩容机制</h4><p>容量1024前 每次扩容2倍，之后扩容1.25倍，一直到超过元素数量或者相等位置。</p>
<p>所以对于数量太大的切片来说，扩容很耗性能，因为每次扩容，切片都会重新分配内存空间，并将原切片的值复制给新切片，原切片被垃圾回收。</p>
<p>如果知道容量的话，一开始指定生成大容量切片较好。使用make语句</p>
<h4 id="byte-和-string-的区别（深层次问题-gt-数组与切片的区别）"><a href="#byte-和-string-的区别（深层次问题-gt-数组与切片的区别）" class="headerlink" title="[]byte{}和 string 的区别（深层次问题-&gt;数组与切片的区别）"></a>[]byte{}和 string 的区别（深层次问题-&gt;数组与切片的区别）</h4><p>string是不可变的字节序列，[]byte{}是可变的字节序列，简单地说string是字节数组，[]byte{}是字节切片</p>
<p>string为UTF-8编码 这导致len不一定是字符串中的个数 而是字节数</p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>切片</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言基础6--context相关</title>
    <url>/2022/08/22/go9/</url>
    <content><![CDATA[<h3 id="context-的使用，context是否并发安全（联动问题-gt-多个协程的同时控制）？"><a href="#context-的使用，context是否并发安全（联动问题-gt-多个协程的同时控制）？" class="headerlink" title="context 的使用，context是否并发安全（联动问题-&gt;多个协程的同时控制）？"></a>context 的使用，context是否并发安全（联动问题-&gt;多个协程的同时控制）？</h3><blockquote>
<p>Go 的 Context 的数据结构包含 Deadline，Done，Err，Value；它可以控制一组呈树状结构的goroutine，每个goroutine拥有相同的上下文。通过context包，可以非常方便地在请求goroutine之间传递请求数据、取消信号和超时信息。</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Context <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
   <span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span>
   <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
   <span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
   <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>基础的context接口只定义了4个方法，下面分别简要说明一下：</p>
<ul>
<li><strong>Deadline</strong> 方法：可以获取设置的截止时间，返回值 deadline 是截止时间，到了这个时间，Context 会自动发起取消请求，返回值 ok 表示是否设置了截止时间。</li>
<li><strong>Done</strong> 方法：返回一个只读的 channel ，类型为 struct{}。如果这个 chan 可以读取，说明已经发出了取消信号，可以做清理操作，然后退出协程，释放资源。</li>
<li><strong>Err</strong> 方法：返回Context 被取消的原因。</li>
<li><strong>Value</strong> 方法：获取 Context 上绑定的值，是一个键值对，通过 key 来获取对应的值。</li>
</ul>
<blockquote>
<p> 最常用的是 Done 方法，在 Context 取消的时候，会关闭这个只读的 Channel，相当于发出了取消信号。</p>
</blockquote>
<span id="more"></span>

<p><strong>其主要的应用 ：</strong></p>
<p><strong>1：上下文控制，2：多个 goroutine 之间的数据交互等，3：超时控制：到某个时间点超时，过多久超时。</strong></p>
<h4 id="Context的使用"><a href="#Context的使用" class="headerlink" title="Context的使用"></a>Context的使用</h4><blockquote>
<p>我们可以使用 select+channel 来实现了部分协程的终止，但是如果我们想要同时取消多个协程怎么办呢？如果需要定时取消又怎么办呢？</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"sync"</span>
	<span class="token string">"time"</span>
<span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
	ctx<span class="token punctuation">,</span> stop <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithCancel</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token function">worker</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token comment">//工作3秒</span>
	<span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//3秒后发出停止指令 context的停止函数</span>
	wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> <span class="token operator">&lt;-</span> ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"结束"</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token keyword">default</span><span class="token punctuation">:</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"运行中..."</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
</blockquote>
<h4 id="context是并发安全的，为什么呢？"><a href="#context是并发安全的，为什么呢？" class="headerlink" title="context是并发安全的，为什么呢？"></a>context是并发安全的，为什么呢？</h4><p>context包提供两种创建根context的方式：</p>
<ul>
<li>context.Backgroud()</li>
<li>context.TODO()</li>
</ul>
<p>又提供了四个函数基于父Context衍生，其中使用WithValue函数来衍生context并携带数据，每次调用WithValue函数都会基于当前context衍生一个新的子context，WithValue内部主要就是调用valueCtx类：</p>
<p>valueCtx结构如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> valueCtx <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
 Context
 key<span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token number">1.2</span><span class="token number">.3</span><span class="token number">.4</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>valueCtx继承父Context，这种是采用匿名接口的继承实现方式，key,val用来存储携带的键值对。</p>
<p>通过上面的代码分析，可以看到添加键值对不是在原context结构体上直接添加，而是以此context作为父节点，重新创建一个新的valueCtx子节点，将键值对添加在子节点上，由此形成一条context链。</p>
<p>获取键值过程也是层层向上调用直到最终的根节点，中间要是找到了key就会返回，否会就会找到最终的emptyCtx返回nil。画个图表示一下：</p>
<p><img src="/2022/08/22/go9/9296c3327c96ad3d25f565bab2b8a5dee8c7ed.webp" alt="img"></p>
<p><strong>总结：</strong>context添加的键值对是链式的，会不断衍生新的context，所以context本身是不可变的，因此是线程安全的。</p>
<blockquote>
<p><strong>参考文章：</strong><a href="https://juejin.cn/post/6986455142480478222">Go语言，并发控制神器之Context - 掘金 (juejin.cn)</a></p>
<p><strong>参考文章：</strong> <a href="https://www.51cto.com/article/700728.html">面试官：Context携带数据是线程安全的吗？-51CTO.COM</a></p>
</blockquote>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>context</tag>
      </tags>
  </entry>
</search>
