<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>为什么代码中实例化结构体时大多要返回结构体指针 而不是结构体值</title>
    <url>/2022/08/17/go2/</url>
    <content><![CDATA[<p>在学习 go 语言项目时，遇到这样一个问题：</p>
<p>通过struct结构体作为一个model，数据绑定等操作都是返回一个结构体指针，那么返回一个结构体变量，或者返回一个结构体指针，他们的区别是什么？</p>
<p>因为二者都可以让我们生成我们所需要的结构体，<strong>那为什么还要去使用返回结构体指针呢</strong>？</p>
<p>对于此疑问，我做了如下实验</p>
<span id="more"></span>

<pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token comment">// TableFile : 文件表结构体</span>
<span class="token keyword">type</span> TableFile <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	FileHash <span class="token builtin">string</span>
	FileName <span class="token builtin">string</span>
	FileSize <span class="token builtin">string</span>
	FileAddr <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// GetFileMeta1  从mysql获取文件元信息</span>
<span class="token keyword">func</span> <span class="token function">GetFileMeta1</span><span class="token punctuation">(</span>filehash1 <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>TableFile <span class="token punctuation">&#123;</span>

	tfile1 <span class="token operator">:=</span> TableFile<span class="token punctuation">&#123;</span>FileHash<span class="token punctuation">:</span> filehash1<span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"GetFileMeta1函数内：%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tfile1<span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>tfile1
<span class="token punctuation">&#125;</span>

<span class="token comment">// GetFileMeta2  从mysql获取文件元信息</span>
<span class="token keyword">func</span> <span class="token function">GetFileMeta2</span><span class="token punctuation">(</span>filehash1 <span class="token builtin">string</span><span class="token punctuation">)</span> TableFile <span class="token punctuation">&#123;</span>

	tfile2 <span class="token operator">:=</span> TableFile<span class="token punctuation">&#123;</span>FileHash<span class="token punctuation">:</span> filehash1<span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"GetFileMeta2函数内：%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tfile2<span class="token punctuation">)</span>
	<span class="token keyword">return</span> tfile2
<span class="token punctuation">&#125;</span>


<span class="token comment">// GetFileMeta3 从mysql获取文件元信息</span>
<span class="token keyword">func</span> <span class="token function">GetFileMeta3</span><span class="token punctuation">(</span>filehash1 <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>tfile3 TableFile<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	tfile3 <span class="token operator">=</span> TableFile<span class="token punctuation">&#123;</span>FileHash<span class="token punctuation">:</span> filehash1<span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"GetFileMeta3函数内：%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tfile3<span class="token punctuation">)</span>
	<span class="token keyword">return</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	t1 <span class="token operator">:=</span> <span class="token function">GetFileMeta1</span><span class="token punctuation">(</span><span class="token string">"1111"</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"GetFileMeta1  函数外%p\n"</span><span class="token punctuation">,</span> t1<span class="token punctuation">)</span>
	t2 <span class="token operator">:=</span> <span class="token function">GetFileMeta2</span><span class="token punctuation">(</span><span class="token string">"1111"</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"GetFileMeta2  函数外%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>t2<span class="token punctuation">)</span>
	t3 <span class="token operator">:=</span> <span class="token function">GetFileMeta3</span><span class="token punctuation">(</span><span class="token string">"1111"</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"GetFileMeta3  函数外%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>t3<span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span>

<span class="token comment">//GetFileMeta1函数内：0xc00005a040</span>
<span class="token comment">//GetFileMeta1  函数外0xc00005a040</span>

<span class="token comment">//GetFileMeta2函数内：0xc00005a0c0</span>
<span class="token comment">//GetFileMeta2  函数外0xc00005a080</span>

<span class="token comment">//GetFileMeta3函数内：0xc00005a140</span>
<span class="token comment">//GetFileMeta3  函数外0xc00005a100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里可以发现：</p>
<ul>
<li>使用指针结构体只分配了一次内存</li>
<li>使用结构体值却分配了两次</li>
</ul>
<p>由于go是值拷贝模式，指针拷贝地址，没有分配多余内存；值拷贝数值，新的变量会重新分配地址给数值。</p>
<p>这一点了解了，可是我仍然不知道指针的性能提升在那里，虽然指针只分配了一次地址空间，可是该空间会分配在堆上发生内存逃逸，影响程序性能；</p>
<p>值空间虽然分配了两次空间，但函数内变量空间分配在栈上，函数结束，系统内核会自动销毁，不影响性能，？难道是多次分配调度内存空间，影响更大？</p>
<!--TODO-->

<p>返回结构体值与结构体指针性能问题</p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言基础1——make和new</title>
    <url>/2022/08/17/go1/</url>
    <content><![CDATA[<h5 id="golang中make和new的区别"><a href="#golang中make和new的区别" class="headerlink" title="golang中make和new的区别"></a>golang中make和new的区别</h5><p>共同点：都是给变量分配内存；<br>不同点：</p>
<ol>
<li><p>返回类型不同： new创建返回指针，指向分配类型的指针，分配的空间置为零，该类型的零值；make返回变量本身，分配空间后会进行初始；</p>
</li>
<li><p>分配类型：new可以为任意类型进行分配；make只能为slice，map，chan引用类型数据进行分配空间。</p>
</li>
</ol>
<h5 id="数组和切片的区别"><a href="#数组和切片的区别" class="headerlink" title="数组和切片的区别"></a>数组和切片的区别</h5><p>共同点：都是通过下标访问，并且都有容量长度；</p>
<p>不同点：</p>
<ol>
<li>定义方式不同：数组必须指定大小，定义后不能增加容量和长度；切片不用，定义后切片数据增多，会自动扩容（当原切片长度小于1024时，新切片的容量会直接翻倍；超过1024会反复地增加25%，直到新容量超过所需要的容量）；</li>
<li>类型不同：数值为值类型；切片为引用类型，每个切片底层引用一个数组，所以切片扩容后，便会指向一个新的底层数组，内存地址跟着改变。</li>
</ol>
<span id="more"></span>

<h5 id="for-range-的时候它的地址会发生变化么？"><a href="#for-range-的时候它的地址会发生变化么？" class="headerlink" title="for range 的时候它的地址会发生变化么？"></a>for range 的时候它的地址会发生变化么？</h5><p>在 for a,b := range c 遍历中，a,b只会存一份地址，循环后会重新赋值，内存地址不变；因此for中创建协程后不要传入a或b的地址，可以再循环中通过创建临时变量解决。</p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>切片</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言基础2——map相关</title>
    <url>/2022/08/18/go3/</url>
    <content><![CDATA[<h5 id="map-中删除一个-key，它的内存会释放么？"><a href="#map-中删除一个-key，它的内存会释放么？" class="headerlink" title="map 中删除一个 key，它的内存会释放么？"></a>map 中删除一个 key，它的内存会释放么？</h5><p>两种情况：</p>
<ol>
<li>value元素为值类型时，不会释放内存</li>
<li>value元素为引用类型时，会释放内存，释放该元素类型所占内存</li>
</ol>
<p>当map置为nil时，内存被回收 [（go垃圾回收)](<a href="https://www.bilibili.com/video/BV1B34y1h73h?spm_id_from=333.337.search-card.all.click">[Go面试]Go GC实现原理?_哔哩哔哩_bilibili</a>)</p>
<span id="more"></span>

<h5 id="map-使用注意的点，是否并发安全？"><a href="#map-使用注意的点，是否并发安全？" class="headerlink" title="map 使用注意的点，是否并发安全？"></a>map 使用注意的点，是否并发安全？</h5><ol>
<li>一定要先初始化，否则panic</li>
<li>map类型(引用类型)是容易发生并发访问问题的。不注意就容易发生程序运行时并发读写导致的panic。 Go语言内建的map对象不是线程安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic。</li>
</ol>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言基础3——GC相关</title>
    <url>/2022/08/18/go4/</url>
    <content><![CDATA[<h5 id="什么是GC"><a href="#什么是GC" class="headerlink" title="什么是GC"></a>什么是GC</h5><p>垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。</p>
<p>堆<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>上分配的数据对象，不会再使用时，不会自动释放内存，就变成垃圾，在程序的运行过程中，如果不能及时清理，会导致越来越多的内存空间被浪费，导致系统性能下降。</p>
<p>因此需要<strong>内存回收</strong>，内存回收分为两种方式:</p>
<ol>
<li><p>手动释放占用内存空间</p>
<p>可能会出现的问题：<br><strong>悬挂指针：</strong> 释放的早了，后续对数据的访问就会出错，因为对应的内存空间可能已经清空，重新分配，甚至是归还给操作系统了。<br><strong>内存泄漏：</strong> 如果忘了释放，一直占用内存，导致内存泄漏。</p>
</li>
<li><p>自动内存回收</p>
<p>程序自动检测对象决定是否要回收其内存。</p>
<p><strong>核心思想：</strong>程序中用得到的数据，一定是可以从栈或数据段这些根节点追踪得到的数据，追踪不到的数据，肯定用不到，也就是垃圾。</p>
<span id="more"></span></li>
</ol>
<h5 id="go-gc-是怎么实现的？"><a href="#go-gc-是怎么实现的？" class="headerlink" title="go gc 是怎么实现的？"></a>go gc 是怎么实现的？</h5><hr>
<p>一次完整的垃圾回收会分为四个阶段，分别是标记准备、标记开始、标记终止、清理：</p>
<ol>
<li><strong>标记准备（Mark Setup）</strong>：打开写屏障（Write Barrier），需 STW（stop the world)</li>
<li><strong>标记开始（Marking）</strong>：使用三色标记法并发标记 ，与用户程序并发执行</li>
<li><strong>标记终止（Mark Termination</strong>）：对触发写屏障的对象进行重新扫描标记，关闭写屏障（Write Barrier），需 STW（stop the world)</li>
<li><strong>清理（Sweeping）</strong>：将需要回收的内存归还到堆中，将过多的内存归还给操作系统，与用户程序并发执行</li>
</ol>
<hr>
<ol>
<li><p><strong>GC机制随着golang版本变化如何变化的？</strong></p>
<p>go 1.3 之前采用<strong>标记清除法</strong>，需要<strong>STW</strong><br>go 1.5 采用<strong>三色标记法</strong>，插入<strong>写屏障机制</strong>（只在堆内存中生效），最后仍需对栈内存进行STW<br>go 1.8 采用混合写屏障机制**，屏障限制只在堆内存中生效。避免了最后节点对栈进行STW的问题，提升了GC效率</p>
</li>
<li><p>一个概念：<strong>STW</strong>：stop the word，指程序执行过程中，中断暂停程序逻辑，专门去进行<a href="https://so.csdn.net/so/search?q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&spm=1001.2101.3001.7020">垃圾回收</a>。（STW<strong>目的是为了防止GC扫描时内存变化引起的混乱</strong>）</p>
</li>
<li><p><strong>标记清除法</strong></p>
<p>从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。</p>
<ul>
<li>开启STW，</li>
<li>从根节点出发，标记所有可达对象 </li>
<li>停止STW，然后回收所有未标记的对象。</li>
<li>优点：解决了引用计数的缺点。</li>
<li>缺点：需要 STW，暂时停掉程序运行。</li>
</ul>
</li>
<li><p><strong>三色标记法【改进的标记清除法】+写屏障机制的流程</strong></p>
</li>
</ol>
<p>三色标记法是对标记阶段的改进，原理如下：</p>
<ul>
<li>初始状态所有对象都是白色。</li>
<li>从root根出发扫描所有根对象（下图a,b），将他们引用的对象标记为灰色（图中A，B）</li>
</ul>
<blockquote>
<p>那么什么是root呢？ 看了很多文章都没解释这这个概念，在这儿说明下：root区域主要是程序运行到当前时刻的栈、寄存器和全局变量。</p>
<p><img src="/2022/08/18/go4/image-20220802113108020.png" alt="image-20220802113108020"></p>
</blockquote>
<ul>
<li><p>遍历灰色对象，将灰色对象引用的对象由白色  也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。</p>
</li>
<li><p>循环步骤3，直到灰色对象全部变黑色。重复以上操作</p>
<blockquote>
<p>其中通过<strong>写屏障</strong>(write-barrier)【<strong>写屏障就是让goroutine与GC同时运行的手段，大大减少STW的时间</strong>，开启后指针传递时会把指针标记，本轮不回收，下轮GC时回收】检测对象有变化；还有一个<strong>辅助GC</strong>(mutator assist)机制【<strong>为防止内存分配过快，GC过程中，辅助GC线程并发运行，协助GC做一部分工作</strong>，先做一部分标记工作】，</p>
</blockquote>
</li>
<li><p>收集所有白色对象（垃圾）。</p>
</li>
</ul>
<p><strong>插入写屏障</strong></p>
<p>对象被引用时触发的机制（只在堆内存中生效）：赋值器这一行为通知给并发执行的回收器，被引用的对象标记为灰色</p>
<p>缺点：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活</p>
<p><strong>删除写屏障</strong></p>
<p>对象被删除时触发的机制（只在堆内存中生效）：赋值器将这一行为通知给并发执行的回收器，被删除的对象，如果自身为灰色或者白色，那么标记为灰色</p>
<p>缺点：一个对象的引用被删除后，即使没有其他存活的对象引用它，它仍然会活到下一轮，会产生很大冗余扫描成本，且降低了回收精度</p>
<p><strong>混合写屏障</strong></p>
<p>GC没有混合写屏障前，一直是插入写屏障；混合写屏障是插入写屏障 + 删除写屏障，写屏障只应用在堆上应用，栈上不启用（栈上启用成本很高）</p>
<ul>
<li>GC开始将栈上的对象全部扫描并标记为黑色。</li>
<li>GC期间，任何在栈上创建的新对象，均为黑色。</li>
<li>被删除的对象标记为灰色。</li>
<li>被添加的对象标记为灰色。</li>
</ul>
<h5 id="GC-的触发时机"><a href="#GC-的触发时机" class="headerlink" title="GC 的触发时机"></a>GC 的触发时机</h5><p><strong>主动触发</strong>：</p>
<ul>
<li>调用 runtime.GC() 方法，触发 GC</li>
</ul>
<p><strong>被动触发：</strong></p>
<ul>
<li>定时触发，该触发条件由 <code>runtime.forcegcperiod</code> 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，触发 GC</li>
<li>根据内存分配阈值触发，该触发条件由环境变量GOGC控制，默认值为100（100%），当前堆内存占用是上次GC结束后占用内存的2倍时，触发GC</li>
</ul>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>GC垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言基础4——Channel相关</title>
    <url>/2022/08/18/go5/</url>
    <content><![CDATA[<h5 id="channel有了解吗？"><a href="#channel有了解吗？" class="headerlink" title="channel有了解吗？"></a>channel有了解吗？</h5><p>它的作用是在上下文中传递除了业务参数之外的额外信息，这个额外信息是为了全局而考虑使用的，例如在微服务业务中，我们需要整个业务链条整体的超时时间信息。不过 go 标准库中的 Context 还提供了超时 Timeout 和 Cancel 机制。总的来说，在下面这些场景中，可以考虑使用 Context：</p>
<ul>
<li>上下文信息传递</li>
<li>控制子 goroutine 的运行</li>
<li>超时控制的方法调用</li>
<li>可以取消的方法调用</li>
</ul>
<p>更具体的场景就是：</p>
<ul>
<li>场景一：RPC调用</li>
<li>场景二：超时请求</li>
<li>场景三：HTTP服务器的request互相传递数据</li>
<li>场景四：PipeLine</li>
</ul>
<span id="more"></span>

<h5 id="go-channel-的底层实现原理-（数据结构）"><a href="#go-channel-的底层实现原理-（数据结构）" class="headerlink" title="go channel 的底层实现原理 （数据结构）"></a>go channel 的底层实现原理 （数据结构）</h5><p>总结hchan结构体的主要组成部分有四个：</p>
<ul>
<li>用来保存goroutine之间传递数据的循环数组：buf</li>
<li>用来记录此循环数组当前发送或接收数据的下标值：sendx（发送队列）和recvx（接受队列）</li>
<li>用于保存向该chan发送和从该chan接收数据被阻塞的goroutine队列： sendq 和 recvq</li>
<li>保证channel写入和读取数据时线程安全的锁：lock</li>
</ul>
<h5 id="go-channel为什么设计成线程安全？"><a href="#go-channel为什么设计成线程安全？" class="headerlink" title="go channel为什么设计成线程安全？"></a>go channel为什么设计成线程安全？</h5><p>不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全</p>
<h5 id="如何实现线程安全的？"><a href="#如何实现线程安全的？" class="headerlink" title="如何实现线程安全的？"></a>如何实现线程安全的？</h5><p>channel的底层实现中，hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据</p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>Channel</tag>
      </tags>
  </entry>
  <entry>
    <title>golang学习路线，所需知识</title>
    <url>/2022/08/17/golangStudy/</url>
    <content><![CDATA[<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="1-操作系统"><a href="#1-操作系统" class="headerlink" title="1. 操作系统"></a>1. 操作系统</h3><ul>
<li><h5 id="了解进程、线程、协程的区别"><a href="#了解进程、线程、协程的区别" class="headerlink" title="了解进程、线程、协程的区别"></a>了解进程、线程、协程的区别</h5></li>
<li><h5 id="了解进程间常用的通信方式"><a href="#了解进程间常用的通信方式" class="headerlink" title="了解进程间常用的通信方式"></a>了解进程间常用的通信方式</h5><ol>
<li>管道</li>
<li>命名管道（FIFO）</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
<li>套接字（Socket）</li>
</ol>
</li>
<li><h5 id="了解5种网络IO模型"><a href="#了解5种网络IO模型" class="headerlink" title="了解5种网络IO模型"></a>了解5种网络IO模型</h5><ol>
<li>阻塞 IO（blocking IO）</li>
<li>非阻塞 IO（non-blocking IO）</li>
<li>多路复用 IO（IO multiplexing）</li>
<li>异步 IO（Asynchronous I/O）</li>
<li>信号驱动 IO（signal driven I/O， SIGIO）</li>
</ol>
<span id="more"></span></li>
<li><h5 id="了解并发与并行的区别"><a href="#了解并发与并行的区别" class="headerlink" title="了解并发与并行的区别"></a>了解并发与并行的区别</h5><ol>
<li>并发是指一个处理器同时处理多个任务。</li>
<li>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。</li>
<li>并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。</li>
<li>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，</li>
<li>并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</li>
</ol>
</li>
<li><h5 id="了解同步与异步的区别"><a href="#了解同步与异步的区别" class="headerlink" title="了解同步与异步的区别"></a>了解同步与异步的区别</h5><ol>
<li>同步：同步是指一个进程在执行某个请求的时候，如果该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去。</li>
<li>异步：异步是指进程不需要一直等待下去，而是继续执行下面的操作，不管其他进程的状态，当有信息返回的时候会通知进程进行处理，这样就可以提高执行的效率了，即异步是我们发出的一个请求，该请求会在后台自动发出并获取数据，然后对数据进行处理，在此过程中，我们可以继续做其他操作，不管它怎么发出请求，不关心它怎么处理数据。</li>
<li>以上总结起来，通俗地讲，也就是说，同步需要按部就班地走完一整个流程，完成一整个动作，打个比方：同步的时候，你在写程序，然后你妈妈叫你马上拖地，你就必须停止写程序然后拖地，没法同时进行。而异步则不需要按部就班，可以在等待那个动作的时候同时做别的动作，</li>
</ol>
</li>
<li><h5 id="了解阻塞与非阻塞的区别"><a href="#了解阻塞与非阻塞的区别" class="headerlink" title="了解阻塞与非阻塞的区别"></a>了解阻塞与非阻塞的区别</h5></li>
<li><h5 id="了解常见缓存淘汰算法："><a href="#了解常见缓存淘汰算法：" class="headerlink" title="了解常见缓存淘汰算法："></a>了解常见缓存淘汰算法：</h5><ol>
<li>LRU（Least Recently Used）最近最少使用算法 </li>
<li>LFU（Least Frequently Used）最近频次最少算法 </li>
<li>FIFO（First In First Out）先入先出算法 </li>
<li>ARC（Adjustable Replacement Cache）自适应缓存替换算法</li>
</ol>
</li>
</ul>
<h3 id="2-计算机网络"><a href="#2-计算机网络" class="headerlink" title="2. 计算机网络"></a>2. 计算机网络</h3><ul>
<li><h5 id="了解网络协议"><a href="#了解网络协议" class="headerlink" title="了解网络协议"></a>了解网络协议</h5></li>
<li><h5 id="了解序列化协议"><a href="#了解序列化协议" class="headerlink" title="了解序列化协议"></a>了解序列化协议</h5></li>
<li><h5 id="了解七层体系结构"><a href="#了解七层体系结构" class="headerlink" title="了解七层体系结构"></a>了解七层体系结构</h5></li>
<li><h5 id="了解四层体系结构"><a href="#了解四层体系结构" class="headerlink" title="了解四层体系结构"></a>了解四层体系结构</h5></li>
</ul>
<h3 id="3-计算机组成原理（冯诺依曼体系）-了解"><a href="#3-计算机组成原理（冯诺依曼体系）-了解" class="headerlink" title="3. 计算机组成原理（冯诺依曼体系）[了解]"></a>3. 计算机组成原理（冯诺依曼体系）[了解]</h3><h3 id="4-数据结构与算法"><a href="#4-数据结构与算法" class="headerlink" title="4. 数据结构与算法"></a>4. 数据结构与算法</h3><ul>
<li><h5 id="了解时间-空间复杂度"><a href="#了解时间-空间复杂度" class="headerlink" title="了解时间/空间复杂度"></a>了解时间/空间复杂度</h5></li>
<li><h5 id="熟悉常用数据结构"><a href="#熟悉常用数据结构" class="headerlink" title="熟悉常用数据结构"></a>熟悉常用数据结构</h5><p>字符串<br>数组<br>链表<br>队列<br>二叉树<br>栈<br>堆</p>
</li>
<li><h5 id="熟悉常用算法"><a href="#熟悉常用算法" class="headerlink" title="熟悉常用算法"></a>熟悉常用算法</h5><p>双指针<br>左右指针<br>排序<br>二叉查找<br>递归<br>回溯<br>贪心<br>动态规划</p>
</li>
</ul>
<h3 id="5-互联网（Internet）"><a href="#5-互联网（Internet）" class="headerlink" title="5. 互联网（Internet）"></a>5. 互联网（Internet）</h3><ul>
<li><h5 id="互联网是如何工作的"><a href="#互联网是如何工作的" class="headerlink" title="互联网是如何工作的"></a>互联网是如何工作的</h5></li>
<li><h5 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h5></li>
<li><h5 id="浏览器以及浏览器如何运作"><a href="#浏览器以及浏览器如何运作" class="headerlink" title="浏览器以及浏览器如何运作"></a>浏览器以及浏览器如何运作</h5></li>
<li><h5 id="域名是什么"><a href="#域名是什么" class="headerlink" title="域名是什么"></a>域名是什么</h5></li>
<li><h5 id="hosting是什么"><a href="#hosting是什么" class="headerlink" title="hosting是什么"></a>hosting是什么</h5></li>
</ul>
<h3 id="6-数据库"><a href="#6-数据库" class="headerlink" title="6. 数据库"></a>6. 数据库</h3><ul>
<li><h5 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h5><p>Mysql</p>
</li>
<li><h5 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h5><p>Redis</p>
</li>
</ul>
<h2 id="Golang编程基础"><a href="#Golang编程基础" class="headerlink" title="Golang编程基础"></a>Golang编程基础</h2><ul>
<li>字符串</li>
<li>常量</li>
<li>变量</li>
<li>类型</li>
<li>操作符</li>
<li>表达式</li>
<li>语句</li>
<li>错误处理</li>
</ul>
<h3 id="1-代码组织"><a href="#1-代码组织" class="headerlink" title="1. 代码组织"></a>1. 代码组织</h3><h3 id="2-标准库"><a href="#2-标准库" class="headerlink" title="2. 标准库"></a>2. 标准库</h3><ul>
<li><h5 id="功能性"><a href="#功能性" class="headerlink" title="功能性"></a>功能性</h5><p>net<br>errors<br>os<br>sync<br>time</p>
</li>
<li><h5 id="输入输出型"><a href="#输入输出型" class="headerlink" title="输入输出型"></a>输入输出型</h5><p>io<br>fmt<br>log</p>
</li>
</ul>
<h3 id="3-版本控制"><a href="#3-版本控制" class="headerlink" title="3. 版本控制"></a>3. 版本控制</h3><ul>
<li><h5 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h5></li>
</ul>
<h2 id="Go编程进阶"><a href="#Go编程进阶" class="headerlink" title="Go编程进阶"></a>Go编程进阶</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li><strong>map</strong></li>
<li><strong>channel</strong></li>
<li><strong>goroutine</strong></li>
<li><strong>slice</strong></li>
<li><strong>runtime</strong></li>
</ul>
<h3 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h3><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><h3 id="CGO"><a href="#CGO" class="headerlink" title="CGO"></a>CGO</h3><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li><strong>单元测试</strong></li>
<li><strong>压力测试</strong></li>
<li><strong>覆盖测试</strong></li>
<li><strong>性能测试</strong></li>
</ul>
<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><ul>
<li><p><strong>goroutine调度</strong></p>
</li>
<li><p><strong>channel调度</strong></p>
</li>
<li><p><strong>锁</strong></p>
</li>
<li><p><strong>waitGroup</strong></p>
</li>
<li><p><strong>context</strong></p>
</li>
<li><p><strong>sync</strong></p>
</li>
<li><p><strong>atomic</strong></p>
</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><img src="/2022/08/17/golangStudy/image-20220805143702043.png" alt="image-20220805143702043"></p>
<h2 id="数据结构与算法（熟练掌握）"><a href="#数据结构与算法（熟练掌握）" class="headerlink" title="数据结构与算法（熟练掌握）"></a>数据结构与算法（熟练掌握）</h2><h2 id="计算机原理与网络"><a href="#计算机原理与网络" class="headerlink" title="计算机原理与网络"></a>计算机原理与网络</h2><p><img src="/2022/08/17/golangStudy/image-20220805143827008.png" alt="image-20220805143827008"></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><img src="/2022/08/17/golangStudy/image-20220805143839926.png" alt="image-20220805143839926"></p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="/2022/08/17/golangStudy/image-20220805143854645.png" alt="image-20220805143854645"></p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><img src="/2022/08/17/golangStudy/image-20220805143913401.png" alt="image-20220805143913401"></p>
<p><img src="/2022/08/17/golangStudy/image-20220805143922828.png" alt="image-20220805143922828"></p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><img src="/2022/08/17/golangStudy/image-20220805143950466.png" alt="image-20220805143950466"></p>
<h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p><img src="/2022/08/17/golangStudy/image-20220805144025693.png" alt="image-20220805144025693"></p>
<h3 id="Web框架"><a href="#Web框架" class="headerlink" title="Web框架"></a>Web框架</h3><p><img src="/2022/08/17/golangStudy/image-20220805144030069.png" alt="image-20220805144030069"></p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p><img src="/2022/08/17/golangStudy/image-20220805144116432.png" alt="image-20220805144116432"></p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>golang学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么InnoDB存储引擎选择使用B+tree索引结构?</title>
    <url>/2022/08/18/mysql2/</url>
    <content><![CDATA[<p>由于B+tree所有数据都在叶子节点，上层节点仅仅起到索引结构，相对于二叉树，层级更少，搜索效率更高！</p>
<p><strong>如图：</strong></p>
<p><img src="/2022/08/18/mysql2/image-20220818153400906.png" alt="image-20220818153400906"></p>
<p>其他结构讲解，链接—-<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68&vd_source=5d110a858f2be0cfcf644f3a61ef01c8">11. 进阶-索引-结构-Btree_哔哩哔哩_bilibili</a></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>Mysql存储引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶1——Mysql存储引擎与索引相关</title>
    <url>/2022/08/18/mysql1/</url>
    <content><![CDATA[<h3 id="MySql存储引擎"><a href="#MySql存储引擎" class="headerlink" title="MySql存储引擎"></a>MySql存储引擎</h3><h4 id="Mysql体系结构"><a href="#Mysql体系结构" class="headerlink" title="Mysql体系结构"></a>Mysql体系结构</h4><ul>
<li>连接层</li>
<li>服务层</li>
<li>引擎层</li>
<li>存储层</li>
</ul>
<h4 id="什么是存储引擎"><a href="#什么是存储引擎" class="headerlink" title="什么是存储引擎"></a>什么是存储引擎</h4><blockquote>
<p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。</p>
</blockquote>
<span id="more"></span>

<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><ul>
<li><p>InnoDB</p>
<pre><code>➢介绍：
      InnoDB是一种兼顾高可靠性和高性能的通用存储引擎,在MySQL 5.5之后, InnoDB是默认的MySQL存储引擎。
  ➢特点：
      DML操作遵循ACID模型，支持事务;
      行级锁，提高并发访问性能; 
      支持外键FOREIGN KEY约束,保证数据的完整性和正确性;
</code></pre>
<p>​    ➢文件：</p>
<p>​        xxx.ibd: xxx代表的是表名, innoDB引擎的每张表都会对应这样一个表空间文件, 存储该表的表结构(frm、 sdi) 、数据和索引。<br>​        参数: innpdb_ file_ per_ table    </p>
<p>​    ➢逻辑存储结构：</p>
<p>​        TableSpece:     表空间</p>
<p>​        |</p>
<p>​        segment:          段<br>​        |</p>
<p>​        Extent:I             区[1M—一个区可以有64个页]<br>​        |</p>
<p>​        Page:                 页[16K]<br>​        |</p>
<p>​        Row:                  行</p>
</li>
</ul>
<p><img src="/2022/08/18/mysql1/image-20220818151444624.png" alt="image-20220818151444624"></p>
<ul>
<li><p>MyISAM</p>
<pre><code>        ➢介绍
              MyISAM是MySQL早期的默认存储引擎。
          ➢特点
              不支持事务,不支持外键
              支持表锁，不支持行锁
              访问速度快
          ➢文件
              xxx.sdi:存储表结构信息
              XXX.MYD:存储数据
              XXX.MYI:存储索引
</code></pre>
</li>
<li><p>Memory</p>
<pre><code>        ➢介绍
              Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。
          ➢特点
              内存存放
              hash索引( 默认)
          ➢文件
              xxx.sdi:存储表结构信息
</code></pre>
</li>
</ul>
<p><strong>MySql存储引擎特点总结：</strong></p>
<p><img src="/2022/08/18/mysql1/image-20220818151922258.png" alt="image-20220818151922258"></p>
<h4 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h4><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<p>​            ➢InnoDB ：是Mysql的默认存储引擎， 支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的-致</p>
<p>​                                性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储 引擎是比较合适的选择。</p>
<p>​            ➢MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那</p>
<p>​                                么选择这个存储引擎是非常合适的。<strong>（现如今被NOSQL-MongoDB替代）</strong></p>
<p>​            ➢MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表</p>
<p>​                                无法缓存在内存中，而且无法保障数据的安全性。<strong>（现如今被NOSQL-Redis替代）</strong></p>
<h3 id="Mysql索引（存储引擎层）"><a href="#Mysql索引（存储引擎层）" class="headerlink" title="Mysql索引（存储引擎层）"></a>Mysql索引（存储引擎层）</h3><h4 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h4><blockquote>
<p>索引(index)是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级的查找算法，这种数据结构就是索引。</p>
<p><strong>简单的说，索引是一种数据结构，一种实现高级查找算法的数据结构。</strong></p>
</blockquote>
<h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构,主要包含以下几种:</p>
<ul>
<li>B+Tree    ——    最常见的索引类型，大部分引擎都支持B+树索引</li>
<li>Hash       ——    底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</li>
<li>R-tree(空间索引)       ——  空间索引是MyISAM弓|擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</li>
<li>Full-text(全文索引)   ——  是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene，Solr，ES</li>
</ul>
<h4 id="索引结构与对应支持引擎"><a href="#索引结构与对应支持引擎" class="headerlink" title="索引结构与对应支持引擎"></a>索引结构与对应支持引擎</h4><p><img src="/2022/08/18/mysql1/image-20220818150013108.png" alt="image-20220818150013108"></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>Mysql存储引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础1</title>
    <url>/2022/08/19/redis1/</url>
    <content><![CDATA[<h1 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h1><blockquote>
<p> Redis是基于内存运行的高性能 K-V 数据库</p>
</blockquote>
<h1 id="Redis存储位置"><a href="#Redis存储位置" class="headerlink" title="Redis存储位置"></a>Redis存储位置</h1><blockquote>
<p> 内存中，所以效率高 </p>
</blockquote>
<h1 id="Redis的五种数据结构"><a href="#Redis的五种数据结构" class="headerlink" title="Redis的五种数据结构"></a>Redis的五种数据结构</h1><blockquote>
</blockquote>
<ul>
<li>String：Redis最基本的数据类型，一个键对应一个值，一个键值最大存储512MB</li>
<li>set：是String字符串类型的无序集合，也不可重复</li>
<li>zset：是String类型的有序集合，也不可重复。有序集合中的每个元素都需要指定一个分数，根据分数对元素进行升序排序</li>
<li>hash：hash是一个键值对的集合，是一个String类型的field和value的映射表，适合用于存储对象</li>
<li>list：是redis的简单的字符串列表，按插入顺序排序</li>
</ul>
<h1 id="Redis应用场景（可以用来做什么）"><a href="#Redis应用场景（可以用来做什么）" class="headerlink" title="Redis应用场景（可以用来做什么）"></a>Redis应用场景（可以用来做什么）</h1><blockquote>
<p> 可用于缓存，事件发布或订阅，高速队列等场景  众多语言都支持Redis，因为Redis交换数据快，在服务器中常用来存储一些需要频繁调取的数据，节省内存开销，也极大的提升了速度。 将一些热点数据存储到Redis中，要用的时候，直接从内存取，极大的提高了速度和节约了服务器的开销。  </p>
</blockquote>
<ul>
<li>会话缓存（最常用）</li>
<li>消息队列（支付）</li>
<li>活动排行榜或计数</li>
<li>发布，订阅消息（消息通知）</li>
<li>商品列表，评论列表</li>
</ul>
<h1 id="为什么使用Redis"><a href="#为什么使用Redis" class="headerlink" title="为什么使用Redis"></a>为什么使用Redis</h1><blockquote>
</blockquote>
<ul>
<li>完全基于内存，数据存在内存中，绝大部分请求是纯粹的内存操作，非常快速，跟传统的磁盘文件数据存储相比，避免了通过磁盘IO读取到内存这部分的开销。</li>
<li>数据结构简单，对数据操作也简单。Redis中的数据结构是专门进行设计的，每种数据结构都有一种或多种数据结构来支持。Redis正是依赖这些灵活的数据结构，来提升读取和写入的性能。</li>
<li>采用单线程，省去了很多上下文切换的时间以及CPU消耗，不存在竞争条件，不用去考虑各种锁的问题，不存在加锁释放锁操作，也不会出现死锁而导致的性能消耗。</li>
<li>使用基于IO多路复用机制的线程模型，可以处理并发的链接。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
</search>
