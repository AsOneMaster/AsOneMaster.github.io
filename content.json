{"meta":{"title":"迅的个人博客","subtitle":"","description":"","author":"asOneMaster","url":"https://AsOneMaster.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-08-17T04:13:22.000Z","updated":"2022-08-17T04:14:12.172Z","comments":true,"path":"categories/index.html","permalink":"https://asonemaster.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-08-17T04:13:30.000Z","updated":"2022-08-17T04:14:29.129Z","comments":true,"path":"tags/index.html","permalink":"https://asonemaster.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"控制gorutine并发数量","slug":"go13","date":"2022-09-13T11:51:01.350Z","updated":"2022-09-13T12:35:29.473Z","comments":true,"path":"2022/09/13/go13/","link":"","permalink":"https://asonemaster.github.io/2022/09/13/go13/","excerpt":"控制并发数量可以避免服务器奔溃：以下方式尝试控制 只是用Chan控制","text":"控制并发数量可以避免服务器奔溃：以下方式尝试控制 只是用Chan控制 package main import ( \"fmt\" ) //控制并发数量 chan func main() &#123; count := 10 ch := make(chan bool, 2) for i := 0; i &lt; count; i++ &#123; ch &lt;- true go read(ch, i) &#125; //time.Sleep(time.Second * 2) &#125; func read(ch chan bool, i int) &#123; fmt.Println(\"第\", i, \"个协程\",time.Now().Unix()) //为了测试并发数量 time.Sleep(time.Second) &lt;-ch &#125; /* 以下为输出---（应该输出10个） 第 1 个协程 1663071133 第 0 个协程 1663071133 第 2 个协程 1663071134 第 3 个协程 1663071134 第 4 个协程 1663071135 第 5 个协程 1663071135 第 6 个协程 1663071136 第 7 个协程 1663071136 第 8 个协程 1663071137 */ 出现问题：看似达到控制2个2个输出的效果，但是主协程结束时，子协程也是会被终止掉的，因此剩余的 goroutine 没来及把值输出， 只使用Sync.WaitGroup // Sync控制 var wg sync.WaitGroup func main() &#123; count := 10 for i := 0; i &lt; count; i++ &#123; wg.Add(1) go read(i) &#125; wg.Wait() &#125; func read(i int) &#123; defer wg.Done() fmt.Println(\"第\", i, \"个协程\", time.Now().Unix()) //为了测试并发数量 time.Sleep(time.Second) &#125; /* 以下为输出---（应该输出10个） 第 9 个协程 1663070879 第 4 个协程 1663070879 第 2 个协程 1663070879 第 3 个协程 1663070879 第 0 个协程 1663070879 第 6 个协程 1663070879 第 5 个协程 1663070879 第 7 个协程 1663070879 第 8 个协程 1663070879 第 1 个协程 1663070879 */ 出现问题：没有达到控制2个2个输出的效果。 使用Sync.WaitGroup+Chan //Sync+Chan var wg sync.WaitGroup func main() &#123; count := 10 ch := make(chan bool, 2) for i := 0; i &lt; count; i++ &#123; wg.Add(1) ch &lt;- true go read(ch, i) &#125; wg.Wait() &#125; func read(ch chan bool, i int) &#123; defer wg.Done() //TODO //ch &lt;- true 放在里面吃内存（待处理 ） fmt.Println(\"第\", i, \"个协程\", time.Now().Unix()) //为了测试并发数量 time.Sleep(time.Second) &lt;-ch &#125; /* 以下为输出---（应该输出10个） 第 1 个协程 1663071133 第 0 个协程 1663071133 第 2 个协程 1663071134 第 3 个协程 1663071134 第 4 个协程 1663071135 第 5 个协程 1663071135 第 6 个协程 1663071136 第 7 个协程 1663071136 第 8 个协程 1663071137 */ 成功：达到控制2个2个输出的效果。 新场景——控制输入的数量，以此达到改变允许并发运行 goroutine 的数量（灵活控制）package main import ( \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup var count int func main() &#123; userCount := 10 ch := make(chan int, 5) for i := 0; i &lt; userCount; i++ &#123; wg.Add(1) go func() &#123; defer wg.Done() for d := range ch &#123; count++ fmt.Println(\"第\", count, \"个协程\", time.Now().Unix()) time.Sleep(time.Second * time.Duration(d)) &#125; &#125;() &#125; for i := 0; i &lt; 10; i++ &#123; //输入几个ch 就有几个*userCount个协程 ch &lt;- 1 ch &lt;- 2 ch &lt;- 3 //time.Sleep(time.Second) &#125; close(ch) wg.Wait() &#125; /* 以下为输出---（应该输出10个） 第 1 个协程 1663072405 第 2 个协程 1663072405 第 4 个协程 1663072405 第 5 个协程 1663072405 第 6 个协程 1663072405 第 7 个协程 1663072405 第 8 个协程 1663072405 第 9 个协程 1663072405 第 10 个协程 1663072405 第 3 个协程 1663072405 第 12 个协程 1663072406 第 13 个协程 1663072406 第 14 个协程 1663072406 第 11 个协程 1663072406 第 15 个协程 1663072407 第 16 个协程 1663072407 第 17 个协程 1663072407 第 18 个协程 1663072407 第 19 个协程 1663072408 第 20 个协程 1663072408 第 21 个协程 1663072408 第 22 个协程 1663072408 第 23 个协程 1663072408 第 24 个协程 1663072408 第 25 个协程 1663072409 第 26 个协程 1663072409 第 28 个协程 1663072409 第 27 个协程 1663072409 第 29 个协程 1663072410 第 30 个协程 1663072410 */","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://asonemaster.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"go基础8-Select相关","slug":"go12","date":"2022-09-13T11:12:49.137Z","updated":"2022-09-13T11:19:28.470Z","comments":true,"path":"2022/09/13/go12/","link":"","permalink":"https://asonemaster.github.io/2022/09/13/go12/","excerpt":"Select的作用select主要用于实现多路监听、实现超时处理 select case后面必须是一个IO操作 一般情况下不用写default select是Go中的一个控制结构，类似于switch语句，用于处理异步I0操作","text":"Select的作用select主要用于实现多路监听、实现超时处理 select case后面必须是一个IO操作 一般情况下不用写default select是Go中的一个控制结构，类似于switch语句，用于处理异步I0操作 如果有多个case都可以运行，select会随机选出一个执行,其他不会执行。 如果没有可运行的case语句，且有default语句， 那么就会执行default的动作。 如果没有可运行的case语句，且没有default语句， select将阻塞，直到某个case通信可以运 select &#123; case IO操作1: I0操作1读取或写入成功就执行 case IO操作2: IO操作2读取或写入成功就执行 default: 如果上面case都没有成功，则进入default处理流程 &#125;","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"channel","slug":"channel","permalink":"https://asonemaster.github.io/tags/channel/"}]},{"title":"控制gorutine顺序输出（生产者——消费者）","slug":"go11","date":"2022-09-08T09:21:44.202Z","updated":"2022-09-13T11:11:57.587Z","comments":true,"path":"2022/09/08/go11/","link":"","permalink":"https://asonemaster.github.io/2022/09/08/go11/","excerpt":"以此铭记失败的面试 go协程开启后是并发执行且无序的；开启100个协程如何对其进行顺序执行?","text":"以此铭记失败的面试 go协程开启后是并发执行且无序的；开启100个协程如何对其进行顺序执行? 第一种方式package main import ( \"fmt\" \"sync\" ) //控制数量 var wg sync.WaitGroup func producter(out &lt;-chan int, in chan&lt;- int) &#123; //阻塞 如果out没有值就一直阻塞 key := &lt;-out fmt.Println(\"生产：\", key) //输入消费管道 in &lt;- key wg.Done() &#125; func consumer(in &lt;-chan int) &#123; for v := range in &#123; fmt.Println(\"消费：\", v) &#125; wg.Done() &#125; func main() &#123; //需要消费的缓冲管道 in := make(chan int, 100) for i := 0; i &lt; 100; i++ &#123; //生产管道 ch := make(chan int) wg.Add(1) //开启生产协程 go producter(ch, in) //将i顺序输入管道 ch &lt;- i //当前协程销毁才能进行下一个 wg.Wait() &#125; //关闭in通道 不然会出错 close(in) wg.Add(1) go consumer(in) wg.Wait() &#125; 下一步计划，尽量熟悉go语言协程开发，不要只停留于理论！吸取教训！ 第二种方式package main import ( \"fmt\" \"sync\" ) //实现有缓冲区与无缓冲区 消费者生产者 var myCh = make(chan int, 100) var exitCh = make(chan bool, 1) var wg sync.WaitGroup func producter(zhu chan int) &#123; num := &lt;-zhu fmt.Println(\"生产了:\", num) myCh &lt;- num wg.Done() &#125; func consumer() &#123; for &#123; if num, ok := &lt;-myCh; !ok &#123; break &#125; else &#123; fmt.Println(\"消费了:\", num) &#125; &#125; fmt.Println(\"停止消费\") wg.Done() exitCh &lt;- true &#125; func main() &#123; for i := 0; i &lt; 100; i++ &#123; zhu := make(chan int) wg.Add(1) go producter(zhu) zhu &lt;- i wg.Wait() close(zhu) &#125; //wg.Wait() close(myCh) wg.Add(1) go consumer() //wg.Wait() fmt.Println(\"exitCh前\") &lt;-exitCh fmt.Println(\"exitCh后\") wg.Wait() &#125;","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://asonemaster.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"云服务器使用man命令出错","slug":"linux3","date":"2022-09-03T02:29:59.106Z","updated":"2022-09-03T02:34:25.713Z","comments":true,"path":"2022/09/03/linux3/","link":"","permalink":"https://asonemaster.github.io/2022/09/03/linux3/","excerpt":"","text":"报错信息：an: preconv: Bad system call (core dumped) man: nroff: Bad system call (core dumped) 找到的原因是man 的版本与linux 的SECCOMP 机制有冲突。找到方法，禁用MAN 的SECCOMP。临时使用：MAN_DISABLE_SECCOMP=1 man ls设到环境变理后：export MAN_DISABLE_SECCOMP=1就可以直接使用，不用每次都加MAN_DISABLE_SECCOMP=1这句。 具体问题待解决~","categories":[{"name":"linux","slug":"linux","permalink":"https://asonemaster.github.io/categories/linux/"}],"tags":[{"name":"文档说明查询","slug":"文档说明查询","permalink":"https://asonemaster.github.io/tags/%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E%E6%9F%A5%E8%AF%A2/"}]},{"title":"什么情况下索引失效","slug":"mysql3","date":"2022-09-01T05:50:14.139Z","updated":"2022-09-01T07:12:37.666Z","comments":true,"path":"2022/09/01/mysql3/","link":"","permalink":"https://asonemaster.github.io/2022/09/01/mysql3/","excerpt":"索引失效情况：索引使用 使用explain 分析索引是否使用 explain select *from tbl_file where file_sha1&#x3D;&#39;0c4b1036671ad0b2727a9d18349d02feae0e8161&#39;; +----+-------------+----------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+ | 1 | SIMPLE | tbl_file | NULL | const | idx_file_hash | idx_file_hash | 120 | const | 1 | 100.00 | NULL | +----+-------------+----------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) possible_keys ：可能索引 key：索引键","text":"索引失效情况：索引使用 使用explain 分析索引是否使用 explain select *from tbl_file where file_sha1&#x3D;&#39;0c4b1036671ad0b2727a9d18349d02feae0e8161&#39;; +----+-------------+----------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+ | 1 | SIMPLE | tbl_file | NULL | const | idx_file_hash | idx_file_hash | 120 | const | 1 | 100.00 | NULL | +----+-------------+----------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) possible_keys ：可能索引 key：索引键 索引列上进行位运算 失效 使用substring explain select *from tbl_file where substring(file_sha1,1,2)&#x3D;&#39;0c&#39;; +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | tbl_file | NULL | ALL | NULL | NULL | NULL | NULL | 1 | 100.00 | Using where | +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) key 为NULL 索引失效 字符串类型不加引号 失效 explain select *from tbl_file where file_sha1&#x3D;123456; +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | tbl_file | NULL | ALL | idx_file_hash | NULL | NULL | NULL | 1 | 100.00 | Using where | +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1 row in set, 3 warnings (0.00 sec) 索引字段使用模糊匹配，头部匹配失效，尾部匹配不会 ##头部匹配 失效 mysql&gt; explain select *from tbl_file where file_sha1 like &#39;%161&#39;; +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | tbl_file | NULL | ALL | NULL | NULL | NULL | NULL | 1 | 100.00 | Using where | +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) ##尾部匹配 索引未失效 mysql&gt; explain select *from tbl_file where file_sha1 like &#39;0c4%&#39;; +----+-------------+----------+------------+-------+---------------+---------------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+-------+---------------+---------------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | tbl_file | NULL | range | idx_file_hash | idx_file_hash | 120 | NULL | 1 | 100.00 | Using index condition | +----+-------------+----------+------------+-------+---------------+---------------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.00 sec) or连 接的条件 用or分割开的条件，如果or前的条件中 的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。 mysql&gt; explain select *from tbl_file where file_sha1&#x3D;&#39;123456&#39; or ext1&#x3D;0; +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | tbl_file | NULL | ALL | idx_file_hash | NULL | NULL | NULL | 1 | 100.00 | Using where | +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) 数据分布影响 如果MySQL评估使用索引比全表更慢，则不使用索引。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://asonemaster.github.io/categories/Mysql/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://asonemaster.github.io/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"linux系统后端常用命令","slug":"linux2","date":"2022-08-24T12:30:55.508Z","updated":"2022-08-25T15:36:44.490Z","comments":true,"path":"2022/08/24/linux2/","link":"","permalink":"https://asonemaster.github.io/2022/08/24/linux2/","excerpt":"","text":"1. 常用指令参考链接连夜整理了多年后端开发最常用linux指令__linux软件运行指令 面试常问的 25+ 个 Linux 命令 - 腾讯云开发者社区-腾讯云 (tencent.com) Linux权限详解（chmod、600、644、700、711、755、777、4755、6755、7755）_林20的博客-CSDN博客_权限700","categories":[{"name":"linux","slug":"linux","permalink":"https://asonemaster.github.io/categories/linux/"}],"tags":[{"name":"常用操作","slug":"常用操作","permalink":"https://asonemaster.github.io/tags/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"}]},{"title":"linux系统","slug":"linux1","date":"2022-08-24T12:21:39.400Z","updated":"2022-08-24T12:32:41.380Z","comments":true,"path":"2022/08/24/linux1/","link":"","permalink":"https://asonemaster.github.io/2022/08/24/linux1/","excerpt":"Linux 最常用命令！ Linux是目前应用最广泛的服务器操作系统，基于Unix，开源免费，由于系统的稳定性和安全性，市场占有率很高，几乎成为程序代码运行的最佳系统环境。 linux不仅可以长时间的运行我们编写的程序代码，还可以安装在各种计算机硬件设备中，如手机、路由器等，Android程序最底层就是运行在linux系统上的。 linux的目录结构","text":"Linux 最常用命令！ Linux是目前应用最广泛的服务器操作系统，基于Unix，开源免费，由于系统的稳定性和安全性，市场占有率很高，几乎成为程序代码运行的最佳系统环境。 linux不仅可以长时间的运行我们编写的程序代码，还可以安装在各种计算机硬件设备中，如手机、路由器等，Android程序最底层就是运行在linux系统上的。 linux的目录结构 bin (binaries)存放二进制可执行文件 sbin (super user binaries)存放二进制可执行文件，只有root才能访问 etc (etcetera)存放系统配置文件 usr (unix shared resources)用于存放共享的系统资源 home 存放用户文件的根目录 root 超级用户目录 dev (devices)用于存放设备文件 lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt (mount)系统管理员安装临时文件系统的安装点 boot 存放用于系统引导时使用的各种文件 tmp (temporary)用于存放各种临时文件 var (variable)用于存放运行时需要改变数据的文件 linux常用命令命令格式：命令 -选项 参数 （选项和参数可以为空） 如：ls -la /usr 操作文件及目录 命令 参数 示例 说明 cd cd /home 切换目录 pwd pwd 显示当前工作目录目录 touch touch 1.txt 创建空文件 mkdir mkdir testdir 创建一个新目录 -p mkidr -p dir1/dir2/dir3/ 创建多级目录，父目录不存在情况下先生成父目录 cp cp 1.txt 复制文件或目录 -r cp -r dir1/ 递归处理，将指定目录下的文件与子目录一并拷贝 mv mv dir1 dir2 移动文件或目录、文件或目录改名 rm rm 1.txt 删除文件 -r rm -rf dir1 r同时删除该目录下的所有文件 -f rm -rf dir1 f强制删除文件或目录 rmdir rmdir dir1 删除空目录 cat cat 1.txt 显示文本文件内容 more more 1.txt 分页显示文本文件内容，可前后翻页，空格向后，b向前 less less 1.txt 分页显示文本文件内容，可前后翻页，空格向后，b向前，支持底行模式（后面介绍） head head 1.txt 查看文本开头部分，默认十行 -[num] head -20 1.txt 查看文本开头部分指定行数 tail tail 1.txt 查看文本结尾部分，默认十行 -[num] tail -20 1.txt 查看文本结尾部分指定行数 -f tail -f 1.txt 循环滚动读取文件并动态显示在屏幕上，根据文件属性追踪 -F tail -F 1.txt 循环滚动读取文件并动态显示在屏幕上，文件文件名追踪 wc wc 1.txt 统计文本的行数、字数、字符数 -m wc -m 1.txt 字符数 -w wc -w 1.txt 文本字数 -l wc -l 1.txt 文本行数 find -name find / -name 1.txt 在文件系统中的指定目录下查找指定的文件 grep grep aaa 1.txt 在指定文件中查找包含指定内容的行，例：在1.txt中查找包含aaa的所有行 ln ln 1.txt 1_bak.txt 建立链接文件 -s ln -s 1.txt 1_bak.txt 对源文件建立符号连接，而非硬连接 系统常用命令 命令 参数 示例 说明 top top 显示当前系统中耗费资源最多的进程 date date 显示系统当前时间 ps 较少单独使用，配参数根据需求，ps -ef 或者ps-aux -e /-A ps -e 显示所有进程，环境变量 -f ps -ef 全格式显示 -a ps -a 显示所有用户的所有进程（包括其它用户） -u ps -au 按用户名和启动时间的顺序来显示进程 -x ps -aux 显示无控制终端的进程 kill -9 kill -9 pid 强制杀死一个进程 df df 显示文件系统磁盘空间的使用情况 -h df -h 以人类可读的方式显示，Kb，Mb，GB等 du 显示指定的目录及其子目录已使用的磁盘空间的总和 -s du -s * 进显示指定目录的总和，星号当前目录下表示所有 -h du -sh * 以人类可读的方式显示，Kb，Mb，GB等 free free 显示当前内存和交换空间的使用情况 ifconfig ifconfig 网卡网络配置，常用于查看当前IP地址 ifconfig eth0 192.168.12.22 临时修改系统IP（重启后失效） ping ping baidu.com 测试网络的连通性 hostname hostname 查看主机名 shutdown -r shutdown -r 先关机，再重启 -h shutdown -h 关机后不重启 halt halt 关机后关闭电源，相当于shutdown -h reboot reboot 重新启动 相当于shutdown -r 压缩解压缩 命令 参数 示例 说明 gzip gzip 1.txt 压缩后面的文件或者文件夹 -d gzip -d 1.txt.gz 解压后面的压缩文件 -[num] gzip -9 1.txt 用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6 tar -c tar -cvf 1.tar 1.txt 建立一个压缩文件的参数指令，例，将1.txt压缩为1.tar，也可指定多个文件或文件夹 -x tar -xvf 1.tar 1.txt 解开一个压缩文件的参数指令 -z tar -zcvf 1.tar.gz 1.txt / tar -zxvf 1.tar.gz 1.txt 是否需要用 gzip ，使用gzip压缩或解压 -v 压缩的过程中显示文件 -f 使用档名，在 f 之后要立即接档名 文件权限操作linux文件权限的描述格式解读 r 可读权限，w可写权限，x可执行权限（也可以用二进制表示 111 110 100 –&gt; 764） 第1位：文件类型（d 目录，- 普通文件，l 链接文件） 第2-4位：所属用户权限，用u（user）表示 第5-7位：所属组权限，用g（group）表示 第8-10位：其他用户权限，用o（other）表示 第2-10位：表示所有的权限，用a（all）表示 命令 参数 示例 说明 chmod chmod u+r 1.txt 修改文件或目录的权限，u表示当前用户，g表示同组用户，o表示其他用户，a表示所有用户，r表示可读，w表示可写，x表示可执行；例：修改1.txt文件给当前用户添加可执行权限 -R chmod -R u+r dir1 修改指定目录及其子目录的所有文件的权限 三位数字 chmod 764 1.sh 直接指定文件的权限，7：表示可读可写可执行，4+2+1；6：表示可读可写，4+2；… chown chown user1:group1 1.txt 修改文件的所属用户和组；例：将1.txt文件的所属用户指定为user1，组为group1 -R chown -R user1:group1 1.txt 修改目录下所有文件及子目录的所属用户和组，用数字来表示权限（r=4，w=2，x=1，-=0） linux系统常用快捷键及符号命令 命令 参数 示例 说明 ctrl + c 停止进程 ctrl + l 清屏 ctrl + r 搜索历史命令 ctrl + q 退出 tab 自动补全 &gt; echo “haha” &gt; 1.txt 将前一条命令的输出，写入到后面的文本中，将文本清空，然后写入 &gt;&gt; echo “lala” &gt;&gt; 1.txt 将前一条命令的输出，写入到后面的文本中，不清空文本，追加到文本最后 cat 1.txt * 通配符，指所有 vim编辑器 vi / vim是Linux上最常用的文本编辑器而且功能非常强大。只有命令，没有菜单，下图表示vi命令的各种模式的切换图。 修改文本 命令 说明 i 在光标前插入 I 在光标当前行开始插入 a 在光标后插入 A 在光标当前行末尾插入 o 在光标当前行的下一行插入新行 O 在光标当前行的上一行插入新行 :wq 保存并退出 q 退出程序 q! 强制退出 w 保存文件 wq filename 保存为指定文件名并退出 定位命令 命令 说明 :set nu 显示行号 :set nonu 取消行号 gg 跳到首行 G 跳到末行 :n 跳到第n行 替换和取消命令 命令 说明 u undo，取消上一步操作 Ctrl + r redo，返回到undo之前 r 替换光标所在处的字符 R 从光标所在处开始替换，按Esc键结束 删除命令 命令 说明 x 删除光标所在处字符 nx 删除光标所在处后的n个字符 dd 删除光标所在行。ndd删除n行 dG 删除光标所在行到末尾行的所以内容 D 删除光标所在处到行尾的内容 :5,7d 删除指定范围的行 常用快捷键 命令 说明 Shift+ zz 保存退出，与“:wq”作用相同 v 进入字符可视模式 V 进入行可视模式 Ctrl + v 进入块可视模式","categories":[{"name":"linux","slug":"linux","permalink":"https://asonemaster.github.io/categories/linux/"}],"tags":[{"name":"常用操作","slug":"常用操作","permalink":"https://asonemaster.github.io/tags/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"}]},{"title":"go语言基础7--defer相关","slug":"go10","date":"2022-08-24T07:05:22.583Z","updated":"2022-08-24T07:25:45.330Z","comments":true,"path":"2022/08/24/go10/","link":"","permalink":"https://asonemaster.github.io/2022/08/24/go10/","excerpt":"1. 多个defer语句，按先进后出的方式执行package main import \"fmt\" func main() &#123; var whatever [5]struct&#123;s&#125; for i := range whatever &#123; defer fmt.Println(i) &#125; &#125; //4 //3 //2 //1 //0","text":"1. 多个defer语句，按先进后出的方式执行package main import \"fmt\" func main() &#123; var whatever [5]struct&#123;s&#125; for i := range whatever &#123; defer fmt.Println(i) &#125; &#125; //4 //3 //2 //1 //0 2. 易错点：defer加func函数带returnpackage main import \"fmt\" //测试函数带参数 直接返回函数参数x再调用defer func test1(x int) int &#123; defer func() &#123; x = 9 &#125;() return x &#125; //测试函数带参数 先赋值x 然后回回函数参数x再调用defer func test11(x int) int &#123; defer func() &#123; x = 9 &#125;() x = 10 return x &#125; //测试函数返回值带参数 先赋值x 然后回回函数参数x再调用defer 但是defer内参数x与返回值参数名相同 直接覆盖原返回值 //结尾return x 是诱导 可以不用写返回值 func test2() (x int) &#123; defer func() &#123; x = 9 &#125;() x = 10 return x //return &#125; //测试函数返回值带参数 同上 覆盖并调用defer得 返回值为10 func test3() (x int) &#123; defer func() &#123; x = 10 &#125;() defer func() &#123; x = 9 &#125;() return x &#125; func main() &#123; fmt.Println(test1(1)) //1 fmt.Println(test11(1)) //10 fmt.Println(test2()) //9 fmt.Println(test3()) //10 &#125; 总结： 执行逻辑 测试函数-&gt;非defer测试函数内局部变量赋值-&gt;return 变量 -&gt;defer函数（如果测试函数有返回值函数且内部变量与返回值参数同名，覆盖return变量值） 更多defer用法参考： Go 延迟调用 defer 用法详解 - 腾讯云开发者社区-腾讯云 (tencent.com)","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"defer","slug":"defer","permalink":"https://asonemaster.github.io/tags/defer/"}]},{"title":"计算机网络1--TCP/HTTP相关","slug":"netWork1","date":"2022-08-23T12:39:18.028Z","updated":"2022-08-24T07:06:13.926Z","comments":true,"path":"2022/08/23/netWork1/","link":"","permalink":"https://asonemaster.github.io/2022/08/23/netWork1/","excerpt":"TCP与UDP的区别 TCP是面向连接的，UDP是无连接的； 什么叫无连接？ UDP发送数据之前不需要建立连接 什么叫不可靠？ UDP接收方收到报文后，不需要给出任何确认 2. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多； TCP是面向字节流的，UDP是面向报文的； 什么意思？ 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。 4. TCP有拥塞控制机制，UDP一般没有（很多研究人员已经提出一种新机制，以促使数据源(包括UDP)执行自适应的拥塞控制”）。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏； 5. TCP首部开销（20字节）比UDP首部开销（8字节）要大 6. UDP 的主机不需要维持复杂的连接状态表 什么时候选择TCP，什么时候选UDP？ 展开 对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失","text":"TCP与UDP的区别 TCP是面向连接的，UDP是无连接的； 什么叫无连接？ UDP发送数据之前不需要建立连接 什么叫不可靠？ UDP接收方收到报文后，不需要给出任何确认 2. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多； TCP是面向字节流的，UDP是面向报文的； 什么意思？ 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。 4. TCP有拥塞控制机制，UDP一般没有（很多研究人员已经提出一种新机制，以促使数据源(包括UDP)执行自适应的拥塞控制”）。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏； 5. TCP首部开销（20字节）比UDP首部开销（8字节）要大 6. UDP 的主机不需要维持复杂的连接状态表 什么时候选择TCP，什么时候选UDP？ 展开 对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失 HTTP可以使用UDP吗？ 展开 HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠 注：http 3.0 使用udp实现 https://zh.wikipedia.org/wiki/HTTP/3 面向连接和无连接的区别 展开 无连接的网络服务（数据报服务）– 面向连接的网络服务（虚电路服务） 虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证； 数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃； TCP如何保证传输的可靠性 数据包校验 对失序数据包重新排序（TCP报文具有序列号） 丢弃重复数据 应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）； 超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据； 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出 HTTP和HTTPS有什么区别？ 端口不同：HTTP使用的是80端口，HTTPS使用443端口； HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全； HTTPS由于加密解密会带来更大的CPU和内存开销； HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买 Https的连接过程？网络协议底层原理（九）：HTTP - 简书 (jianshu.com) 展开 客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）； 服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）； 客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配； 如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个随机密钥（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行摘要计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器； 服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器； 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密 总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。 输入 www.baidu.com，怎么变成 https://www.baidu.com 的，怎么确定用HTTP还是HTTPS？ 展开 你访问的网站是如何自动切换到 HTTPS 的？ 一种是原始的302跳转，服务器把所有的HTTp流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。解决方法是引入HSTS机制，用户浏览器在访问站点的时候强制使用HTTPS。 HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？ 展开 1.验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证； 2.判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证； 3.判断证书是否被篡改。需要与 CA 服务器进行校验； 4.判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与 CA 服务器的交互，提高验证效率 什么是对称加密、非对称加密？区别是什么？ 展开 对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4 非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA 区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥） 数字签名、报文摘要的原理 展开 - 发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。 - 摘要算法:MD5、SHA","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://asonemaster.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://asonemaster.github.io/tags/TCP/"},{"name":"HTTP","slug":"HTTP","permalink":"https://asonemaster.github.io/tags/HTTP/"}]},{"title":"go语言基础6--context相关","slug":"go9","date":"2022-08-22T08:38:05.118Z","updated":"2022-08-22T10:42:38.296Z","comments":true,"path":"2022/08/22/go9/","link":"","permalink":"https://asonemaster.github.io/2022/08/22/go9/","excerpt":"context 的使用，context是否并发安全（联动问题-&gt;多个协程的同时控制）？ Go 的 Context 的数据结构包含 Deadline，Done，Err，Value；它可以控制一组呈树状结构的goroutine，每个goroutine拥有相同的上下文。通过context包，可以非常方便地在请求goroutine之间传递请求数据、取消信号和超时信息。 type Context interface &#123; Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct&#123;&#125; Err() error Value(key interface&#123;&#125;) interface&#123;&#125; &#125; 基础的context接口只定义了4个方法，下面分别简要说明一下： Deadline 方法：可以获取设置的截止时间，返回值 deadline 是截止时间，到了这个时间，Context 会自动发起取消请求，返回值 ok 表示是否设置了截止时间。 Done 方法：返回一个只读的 channel ，类型为 struct{}。如果这个 chan 可以读取，说明已经发出了取消信号，可以做清理操作，然后退出协程，释放资源。 Err 方法：返回Context 被取消的原因。 Value 方法：获取 Context 上绑定的值，是一个键值对，通过 key 来获取对应的值。 最常用的是 Done 方法，在 Context 取消的时候，会关闭这个只读的 Channel，相当于发出了取消信号。","text":"context 的使用，context是否并发安全（联动问题-&gt;多个协程的同时控制）？ Go 的 Context 的数据结构包含 Deadline，Done，Err，Value；它可以控制一组呈树状结构的goroutine，每个goroutine拥有相同的上下文。通过context包，可以非常方便地在请求goroutine之间传递请求数据、取消信号和超时信息。 type Context interface &#123; Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct&#123;&#125; Err() error Value(key interface&#123;&#125;) interface&#123;&#125; &#125; 基础的context接口只定义了4个方法，下面分别简要说明一下： Deadline 方法：可以获取设置的截止时间，返回值 deadline 是截止时间，到了这个时间，Context 会自动发起取消请求，返回值 ok 表示是否设置了截止时间。 Done 方法：返回一个只读的 channel ，类型为 struct{}。如果这个 chan 可以读取，说明已经发出了取消信号，可以做清理操作，然后退出协程，释放资源。 Err 方法：返回Context 被取消的原因。 Value 方法：获取 Context 上绑定的值，是一个键值对，通过 key 来获取对应的值。 最常用的是 Done 方法，在 Context 取消的时候，会关闭这个只读的 Channel，相当于发出了取消信号。 其主要的应用 ： 1：上下文控制，2：多个 goroutine 之间的数据交互等，3：超时控制：到某个时间点超时，过多久超时。 Context的使用 我们可以使用 select+channel 来实现了部分协程的终止，但是如果我们想要同时取消多个协程怎么办呢？如果需要定时取消又怎么办呢？ package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) func main() &#123; var wg sync.WaitGroup ctx, stop := context.WithCancel(context.Background()) wg.Add(1) go func() &#123; defer wg.Done() worker(ctx) &#125;() time.Sleep(3*time.Second) //工作3秒 stop() //3秒后发出停止指令 context的停止函数 wg.Wait() &#125; func worker(ctx context.Context)&#123; for &#123; select &#123; case &lt;- ctx.Done(): fmt.Println(\"结束\") return default: fmt.Println(\"运行中...\") &#125; time.Sleep(1*time.Second) &#125; &#125; context是并发安全的，为什么呢？context包提供两种创建根context的方式： context.Backgroud() context.TODO() 又提供了四个函数基于父Context衍生，其中使用WithValue函数来衍生context并携带数据，每次调用WithValue函数都会基于当前context衍生一个新的子context，WithValue内部主要就是调用valueCtx类： valueCtx结构如下： type valueCtx struct &#123; Context key, val interface&#123;&#125; &#125; 1.2.3.4. valueCtx继承父Context，这种是采用匿名接口的继承实现方式，key，val用来存储携带的键值对。 通过上面的代码分析，可以看到添加键值对不是在原context结构体上直接添加，而是以此context作为父节点，重新创建一个新的valueCtx子节点，将键值对添加在子节点上，由此形成一条context链。 获取键值过程也是层层向上调用直到最终的根节点，中间要是找到了key就会返回，否会就会找到最终的emptyCtx返回nil。画个图表示一下： 总结：context添加的键值对是链式的，会不断衍生新的context，所以context本身是不可变的，因此是线程安全的。 参考文章：Go语言，并发控制神器之Context - 掘金 (juejin.cn) 参考文章： 面试官：Context携带数据是线程安全的吗？-51CTO.COM","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"context","slug":"context","permalink":"https://asonemaster.github.io/tags/context/"}]},{"title":"go语言基础5--切片与数组相关","slug":"go8","date":"2022-08-22T08:13:07.157Z","updated":"2022-08-22T08:39:27.136Z","comments":true,"path":"2022/08/22/go8/","link":"","permalink":"https://asonemaster.github.io/2022/08/22/go8/","excerpt":"slice 和 array的区别？（下级问题-&gt;slice底层与扩容机制） 数组的零值是元素类型的零值，切片的零值是 nil； 数组是固定长度，切片是可变长度； 数组是值类型，切片是引用类型。 slice的底层实现 slice 底层 是有 3 个字段的数据结构分为： array 数组 len 长度 cap 容量 指针指向数组的第一个该 slice 可访问的元素，这个元素并不一定是底层数组的第一个元素，长度是指 slice 中元素的个数，它不能超过 slice 的容量。 容量的大小通常是从 slice 底层数组的元素个数，什么意思呢举例： arr：=[]int{1,2,3,4} slice:=arr[1:3] —（即：{2，3，4}） slice的长度为3 容量为4（{1，2，3，4}为底层数组） Go 的内置函数 len 和 cap 用来返回 slice 的长度和容量。","text":"slice 和 array的区别？（下级问题-&gt;slice底层与扩容机制） 数组的零值是元素类型的零值，切片的零值是 nil； 数组是固定长度，切片是可变长度； 数组是值类型，切片是引用类型。 slice的底层实现 slice 底层 是有 3 个字段的数据结构分为： array 数组 len 长度 cap 容量 指针指向数组的第一个该 slice 可访问的元素，这个元素并不一定是底层数组的第一个元素，长度是指 slice 中元素的个数，它不能超过 slice 的容量。 容量的大小通常是从 slice 底层数组的元素个数，什么意思呢举例： arr：=[]int{1,2,3,4} slice:=arr[1:3] —（即：{2，3，4}） slice的长度为3 容量为4（{1，2，3，4}为底层数组） Go 的内置函数 len 和 cap 用来返回 slice 的长度和容量。 slice扩容机制容量1024前 每次扩容2倍，之后扩容1.25倍，一直到超过元素数量或者相等位置。 所以对于数量太大的切片来说，扩容很耗性能，因为每次扩容，切片都会重新分配内存空间，并将原切片的值复制给新切片，原切片被垃圾回收。 如果知道容量的话，一开始指定生成大容量切片较好。使用make语句 []byte{}和 string 的区别（深层次问题-&gt;数组与切片的区别）string是不可变的字节序列，[]byte{}是可变的字节序列，简单地说string是字节数组，[]byte{}是字节切片 string为UTF-8编码 这导致len不一定是字符串中的个数 而是字节数","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://asonemaster.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"切片","slug":"切片","permalink":"https://asonemaster.github.io/tags/%E5%88%87%E7%89%87/"}]},{"title":"逃逸分析能做什么？如何进行逃逸分析？","slug":"go7","date":"2022-08-20T08:56:32.976Z","updated":"2022-08-22T08:17:15.846Z","comments":true,"path":"2022/08/20/go7/","link":"","permalink":"https://asonemaster.github.io/2022/08/20/go7/","excerpt":"（上级垃圾回收 问题逻辑- 垃圾回收-&gt;逃逸分析-&gt;内存逃逸） 逃逸分析是什么：编译器决定内存分配位置的方式，就称之为逃逸分析(escape analysis)。逃逸分析由编译器完成，作用于编译阶段。 逃逸分析能做什么：可以了解程序哪些内存在栈上，哪些在堆上，从而优化减少垃圾回收提升性能。 如何进行逃逸分析：go语言可以使用go build -gcflags ‘-m -N -l’ test.go 的方式 查看编译结果中的逃逸情况 在堆上（heap）的就发生了逃逸 必然不会发生逃逸的情况： 指针被没有发生逃逸的变量引用 仅仅在函数被对变量进行取地址操作，没有将指针传出","text":"（上级垃圾回收 问题逻辑- 垃圾回收-&gt;逃逸分析-&gt;内存逃逸） 逃逸分析是什么：编译器决定内存分配位置的方式，就称之为逃逸分析(escape analysis)。逃逸分析由编译器完成，作用于编译阶段。 逃逸分析能做什么：可以了解程序哪些内存在栈上，哪些在堆上，从而优化减少垃圾回收提升性能。 如何进行逃逸分析：go语言可以使用go build -gcflags ‘-m -N -l’ test.go 的方式 查看编译结果中的逃逸情况 在堆上（heap）的就发生了逃逸 必然不会发生逃逸的情况： 指针被没有发生逃逸的变量引用 仅仅在函数被对变量进行取地址操作，没有将指针传出 一定逃逸 构造函数new/make 返回的指针变量一定逃逸 被已经逃逸指针变量引用指针，一定发生逃逸 指针类型是slice，map,chan 引用指针一定发生逃逸 Maybe 逃逸 将指针作为入参传给别的函数，这里看指针在被传入函数的处理过程，如果发生上边三种情况会逃逸，否则不会 传值 VS 传指针： 传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。 一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"内存逃逸","slug":"内存逃逸","permalink":"https://asonemaster.github.io/tags/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/"}]},{"title":"goroutine(协程)和线程是什么关系，goroutine是如何调度的？","slug":"go6","date":"2022-08-20T08:04:38.465Z","updated":"2022-08-22T08:17:30.066Z","comments":true,"path":"2022/08/20/go6/","link":"","permalink":"https://asonemaster.github.io/2022/08/20/go6/","excerpt":"（上级问题并发 问题逻辑- 并发机制-&gt;GMP-&gt;goroutine调度） goroutine(协程)和线程说线程之前，我们先说进程和线程的关系， 首先线程是进程的执行体，拥有一个执行入口，以及进程虚拟地址空间中分配的栈—包括用户栈和内核栈，操作系统会记录线程控制信息， 而线程会在获得cpu时间片信息后执行 ，cpu中栈指针、指令指针等寄存器都到切换到对应的线程； 而协程就是线程创建的执行体，其控制信息由线程记录，由于用户程序不能操作内核空间，所以只能给协程分配用户栈，而操作系统对这个信息一无所知。 总结：协程是一种”用户态线程”。 goroutine如何调度说到goroutine的调度就不得不提MPG（GMP）模型 M: 线程 P: 执行go协程运行所必需的资源，关联本地可运行G的队列 G: go协程","text":"（上级问题并发 问题逻辑- 并发机制-&gt;GMP-&gt;goroutine调度） goroutine(协程)和线程说线程之前，我们先说进程和线程的关系， 首先线程是进程的执行体，拥有一个执行入口，以及进程虚拟地址空间中分配的栈—包括用户栈和内核栈，操作系统会记录线程控制信息， 而线程会在获得cpu时间片信息后执行 ，cpu中栈指针、指令指针等寄存器都到切换到对应的线程； 而协程就是线程创建的执行体，其控制信息由线程记录，由于用户程序不能操作内核空间，所以只能给协程分配用户栈，而操作系统对这个信息一无所知。 总结：协程是一种”用户态线程”。 goroutine如何调度说到goroutine的调度就不得不提MPG（GMP）模型 M: 线程 P: 执行go协程运行所必需的资源，关联本地可运行G的队列 G: go协程 G，M，P的个数 M 的数据默认启动的时候是 10000，内核很难支持这么多线程数，所以整个限制客户忽略，M 一般不做设置，设置好 P，M 一般都是要大于 P。 P 的数量一般建议是逻辑 CPU 数量的 2 倍。——使用runtime.GOMAXPROCS() 变量数一般是cpu核数的2倍，具体看性能分析。 G 的个数理论上是无限制的，但是受内存限制。 一开始go创建时只有MG，多个M分担多个G的执行任务时（想象整体G是一个全局队列，多个M执行G时），就会因为频繁 加锁解锁（不能让其他线程执行到同一个G）而发生等待，影响并发性能。所以，使用P，p有一个本地队列，这样只要M关联到P，就可以直接运行队列中待执行的G，不用每次从全局队列中争抢了。 （注意一个问题：程序中主进程结束不管协程有没有运行完，都会结束，所以一般使用wg sync.WaitGroup wg.Add() go func(){ wg.Done} wg.Wait()） 总结GMP调度流程： 线程M想运行任务就需得获取 P，即与P关联。 然从 P 的本地队列(LRQ)获取 G 若LRQ中没有可运行的G，M 会尝试从全局队列(GRQ)拿一批G放到P的本地队列， 若全局队列也未找到可运行的G时候，M会随机从其他 P 的本地队列偷一半放到自己 P 的本地队列。 拿到可运行的G之后，M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。 Go如何有效控制Goroutine并发数量","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://asonemaster.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"goroutine","slug":"goroutine","permalink":"https://asonemaster.github.io/tags/goroutine/"}]},{"title":"go语言的并发机制","slug":"goRoutine","date":"2022-08-19T13:28:44.044Z","updated":"2022-08-19T14:51:18.028Z","comments":true,"path":"2022/08/19/goRoutine/","link":"","permalink":"https://asonemaster.github.io/2022/08/19/goRoutine/","excerpt":"","text":"go语言并发原理 Go不推荐用共享内存的方式传递数据，而推荐使用channel(或称“通道” )。channel主要用来在多个goroutine之间传递数据，并且还 会保证整个过程的并发安全性。不过，作为可选方法，Go依然提供了一些传统的同步方法 (比如互斥量、 条件变量等)。 Go的并发机制指的是用于支撑goroutine 和channel的底层原理，说到这个就不得不提go语言的调度模型，GMP。 GMP调度模型说起Go的线程实现模型,有3个必知的核心元素,它们支撑起了这个模型的主框架，简要说明如下： M: machine的缩写。一个M代表一个内核线程，或称“工作线程”。 P: processor的缩写。一个P代表执行一个Go代码片段所必需的资源(或称“上下文环境”)。 G: goroutine的缩写。一个G代表一 个Go代码片段。前者是对后者的一种封装。 .未完待续~~~","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://asonemaster.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"Redis基础1","slug":"redis1","date":"2022-08-19T13:12:39.632Z","updated":"2022-08-19T13:29:59.909Z","comments":true,"path":"2022/08/19/redis1/","link":"","permalink":"https://asonemaster.github.io/2022/08/19/redis1/","excerpt":"Redis是什么 Redis是基于内存运行的高性能 K-V 数据库 Redis存储位置 内存中，所以效率高 Redis的五种数据结构 String：Redis最基本的数据类型，一个键对应一个值，一个键值最大存储512MB set：是String字符串类型的无序集合，也不可重复 zset：是String类型的有序集合，也不可重复。有序集合中的每个元素都需要指定一个分数，根据分数对元素进行升序排序","text":"Redis是什么 Redis是基于内存运行的高性能 K-V 数据库 Redis存储位置 内存中，所以效率高 Redis的五种数据结构 String：Redis最基本的数据类型，一个键对应一个值，一个键值最大存储512MB set：是String字符串类型的无序集合，也不可重复 zset：是String类型的有序集合，也不可重复。有序集合中的每个元素都需要指定一个分数，根据分数对元素进行升序排序 hash：hash是一个键值对的集合，是一个String类型的field和value的映射表，适合用于存储对象 list：是redis的简单的字符串列表，按插入顺序排序 Redis应用场景（可以用来做什么） 可用于缓存，事件发布或订阅，高速队列等场景 众多语言都支持Redis，因为Redis交换数据快，在服务器中常用来存储一些需要频繁调取的数据，节省内存开销，也极大的提升了速度。 将一些热点数据存储到Redis中，要用的时候，直接从内存取，极大的提高了速度和节约了服务器的开销。 会话缓存（最常用） 消息队列（支付） 活动排行榜或计数 发布，订阅消息（消息通知） 商品列表，评论列表 为什么使用Redis 完全基于内存，数据存在内存中，绝大部分请求是纯粹的内存操作，非常快速，跟传统的磁盘文件数据存储相比，避免了通过磁盘IO读取到内存这部分的开销。 数据结构简单，对数据操作也简单。Redis中的数据结构是专门进行设计的，每种数据结构都有一种或多种数据结构来支持。Redis正是依赖这些灵活的数据结构，来提升读取和写入的性能。 采用单线程，省去了很多上下文切换的时间以及CPU消耗，不存在竞争条件，不用去考虑各种锁的问题，不存在加锁释放锁操作，也不会出现死锁而导致的性能消耗。 使用基于IO多路复用机制的线程模型，可以处理并发的链接。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://asonemaster.github.io/categories/Redis/"}],"tags":[{"name":"概念","slug":"概念","permalink":"https://asonemaster.github.io/tags/%E6%A6%82%E5%BF%B5/"}]},{"title":"为什么InnoDB存储引擎选择使用B+tree索引结构?","slug":"mysql2","date":"2022-08-18T07:28:53.900Z","updated":"2022-08-18T07:35:14.682Z","comments":true,"path":"2022/08/18/mysql2/","link":"","permalink":"https://asonemaster.github.io/2022/08/18/mysql2/","excerpt":"","text":"由于B+tree所有数据都在叶子节点，上层节点仅仅起到索引结构，相对于二叉树，层级更少，搜索效率更高！ 如图： 其他结构讲解，链接—-11. 进阶-索引-结构-Btree_哔哩哔哩_bilibili","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://asonemaster.github.io/categories/Mysql/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://asonemaster.github.io/tags/%E7%B4%A2%E5%BC%95/"},{"name":"Mysql存储引擎","slug":"Mysql存储引擎","permalink":"https://asonemaster.github.io/tags/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"}]},{"title":"Mysql进阶1——Mysql存储引擎与索引相关","slug":"mysql1","date":"2022-08-18T06:42:08.272Z","updated":"2022-08-18T07:37:45.025Z","comments":true,"path":"2022/08/18/mysql1/","link":"","permalink":"https://asonemaster.github.io/2022/08/18/mysql1/","excerpt":"MySql存储引擎Mysql体系结构 连接层 服务层 引擎层 存储层 什么是存储引擎 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。","text":"MySql存储引擎Mysql体系结构 连接层 服务层 引擎层 存储层 什么是存储引擎 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。 存储引擎 InnoDB ➢介绍： InnoDB是一种兼顾高可靠性和高性能的通用存储引擎,在MySQL 5.5之后, InnoDB是默认的MySQL存储引擎。 ➢特点： DML操作遵循ACID模型，支持事务; 行级锁，提高并发访问性能; 支持外键FOREIGN KEY约束,保证数据的完整性和正确性; ​ ➢文件： ​ xxx.ibd: xxx代表的是表名, innoDB引擎的每张表都会对应这样一个表空间文件, 存储该表的表结构(frm、 sdi) 、数据和索引。​ 参数: innpdb_ file_ per_ table ​ ➢逻辑存储结构： ​ TableSpece: 表空间 ​ | ​ segment: 段​ | ​ Extent:I 区[1M—一个区可以有64个页]​ | ​ Page: 页[16K]​ | ​ Row: 行 MyISAM ➢介绍 MyISAM是MySQL早期的默认存储引擎。 ➢特点 不支持事务,不支持外键 支持表锁，不支持行锁 访问速度快 ➢文件 xxx.sdi:存储表结构信息 XXX.MYD:存储数据 XXX.MYI:存储索引 Memory ➢介绍 Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。 ➢特点 内存存放 hash索引( 默认) ➢文件 xxx.sdi:存储表结构信息 MySql存储引擎特点总结： 存储引擎选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。 ​ ➢InnoDB ：是Mysql的默认存储引擎， 支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的-致 ​ 性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储 引擎是比较合适的选择。 ​ ➢MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那 ​ 么选择这个存储引擎是非常合适的。（现如今被NOSQL-MongoDB替代） ​ ➢MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表 ​ 无法缓存在内存中，而且无法保障数据的安全性。（现如今被NOSQL-Redis替代） Mysql索引（存储引擎层）什么是索引 索引(index)是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级的查找算法，这种数据结构就是索引。 简单的说，索引是一种数据结构，一种实现高级查找算法的数据结构。 索引结构MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构,主要包含以下几种: B+Tree —— 最常见的索引类型，大部分引擎都支持B+树索引 Hash —— 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询 R-tree(空间索引) —— 空间索引是MyISAM弓|擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-text(全文索引) —— 是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene，Solr，ES 索引结构与对应支持引擎","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://asonemaster.github.io/categories/Mysql/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://asonemaster.github.io/tags/%E7%B4%A2%E5%BC%95/"},{"name":"Mysql存储引擎","slug":"Mysql存储引擎","permalink":"https://asonemaster.github.io/tags/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"}]},{"title":"go语言基础4——Channel相关","slug":"go5","date":"2022-08-18T03:31:24.180Z","updated":"2022-08-20T06:12:04.779Z","comments":true,"path":"2022/08/18/go5/","link":"","permalink":"https://asonemaster.github.io/2022/08/18/go5/","excerpt":"channel 是否线程安全？锁用在什么地方？ Golang的Channel,发送一个数据到Channel 和 从Channel接收一个数据都是原子性的。 如果把线程安全定义为允许多个goroutine同时去读写，那么golang 的channel 是线程安全的，因为channel底层数据结构中是带有lock的，不需要在并发读写同一个channe时再加锁。 而且Go的设计思想就是：不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁（共享内存通信），后者就是Channel。 也就是说，设计Channel的主要目的就是在多任务间传递数据的，这当然是安全的 go channel 的底层实现原理 （数据结构）总结hchan结构体的主要组成部分有四个： 用来保存goroutine之间传递数据的循环数组：buf 用来记录此循环数组当前发送或接收数据的下标值：sendx（发送队列）和recvx（接受队列） 用于保存向该chan发送和从该chan接收数据被阻塞的goroutine队列： sendq 和 recvq 保证channel写入和读取数据时线程安全的锁：lock","text":"channel 是否线程安全？锁用在什么地方？ Golang的Channel,发送一个数据到Channel 和 从Channel接收一个数据都是原子性的。 如果把线程安全定义为允许多个goroutine同时去读写，那么golang 的channel 是线程安全的，因为channel底层数据结构中是带有lock的，不需要在并发读写同一个channe时再加锁。 而且Go的设计思想就是：不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁（共享内存通信），后者就是Channel。 也就是说，设计Channel的主要目的就是在多任务间传递数据的，这当然是安全的 go channel 的底层实现原理 （数据结构）总结hchan结构体的主要组成部分有四个： 用来保存goroutine之间传递数据的循环数组：buf 用来记录此循环数组当前发送或接收数据的下标值：sendx（发送队列）和recvx（接受队列） 用于保存向该chan发送和从该chan接收数据被阻塞的goroutine队列： sendq 和 recvq 保证channel写入和读取数据时线程安全的锁：lock go channel为什么设计成线程安全？不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全 如何实现线程安全的？channel的底层实现中，hchan结构体中采用Mutex（互斥）锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据 nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？ 读写值 nil 管道会永久阻塞 关闭的管道读数据仍然可以读数据 往关闭的管道写数据会 panic 关闭为 nil 的管道会 panic 关闭已经关闭的管道 panic 总结：对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。如果我们试图关闭一个已经关闭了的通道，也会引发 panic。 使用场景： 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Channel","slug":"Channel","permalink":"https://asonemaster.github.io/tags/Channel/"}]},{"title":"go语言基础3——GC相关","slug":"go4","date":"2022-08-18T03:28:55.755Z","updated":"2022-08-18T03:30:39.791Z","comments":true,"path":"2022/08/18/go4/","link":"","permalink":"https://asonemaster.github.io/2022/08/18/go4/","excerpt":"什么是GC垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。 堆内存上分配的数据对象，不会再使用时，不会自动释放内存，就变成垃圾，在程序的运行过程中，如果不能及时清理，会导致越来越多的内存空间被浪费，导致系统性能下降。 因此需要内存回收，内存回收分为两种方式: 手动释放占用内存空间 可能会出现的问题：悬挂指针： 释放的早了，后续对数据的访问就会出错，因为对应的内存空间可能已经清空，重新分配，甚至是归还给操作系统了。内存泄漏： 如果忘了释放，一直占用内存，导致内存泄漏。 自动内存回收 程序自动检测对象决定是否要回收其内存。 核心思想：程序中用得到的数据，一定是可以从栈或数据段这些根节点追踪得到的数据，追踪不到的数据，肯定用不到，也就是垃圾。","text":"什么是GC垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。 堆内存上分配的数据对象，不会再使用时，不会自动释放内存，就变成垃圾，在程序的运行过程中，如果不能及时清理，会导致越来越多的内存空间被浪费，导致系统性能下降。 因此需要内存回收，内存回收分为两种方式: 手动释放占用内存空间 可能会出现的问题：悬挂指针： 释放的早了，后续对数据的访问就会出错，因为对应的内存空间可能已经清空，重新分配，甚至是归还给操作系统了。内存泄漏： 如果忘了释放，一直占用内存，导致内存泄漏。 自动内存回收 程序自动检测对象决定是否要回收其内存。 核心思想：程序中用得到的数据，一定是可以从栈或数据段这些根节点追踪得到的数据，追踪不到的数据，肯定用不到，也就是垃圾。 go gc 是怎么实现的？ 一次完整的垃圾回收会分为四个阶段，分别是标记准备、标记开始、标记终止、清理： 标记准备（Mark Setup）：打开写屏障（Write Barrier），需 STW（stop the world) 标记开始（Marking）：使用三色标记法并发标记 ，与用户程序并发执行 标记终止（Mark Termination）：对触发写屏障的对象进行重新扫描标记，关闭写屏障（Write Barrier），需 STW（stop the world) 清理（Sweeping）：将需要回收的内存归还到堆中，将过多的内存归还给操作系统，与用户程序并发执行 GC机制随着golang版本变化如何变化的？ go 1.3 之前采用标记清除法，需要STWgo 1.5 采用三色标记法，插入写屏障机制（只在堆内存中生效），最后仍需对栈内存进行STWgo 1.8 采用混合写屏障机制**，屏障限制只在堆内存中生效。避免了最后节点对栈进行STW的问题，提升了GC效率 一个概念：STW：stop the word，指程序执行过程中，中断暂停程序逻辑，专门去进行垃圾回收。（STW目的是为了防止GC扫描时内存变化引起的混乱） 标记清除法 从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。 开启STW， 从根节点出发，标记所有可达对象 停止STW，然后回收所有未标记的对象。 优点：解决了引用计数的缺点。 缺点：需要 STW，暂时停掉程序运行。 三色标记法【改进的标记清除法】+写屏障机制的流程 三色标记法是对标记阶段的改进，原理如下： 初始状态所有对象都是白色。 从root根出发扫描所有根对象（下图a,b），将他们引用的对象标记为灰色（图中A，B） 那么什么是root呢？ 看了很多文章都没解释这这个概念，在这儿说明下：root区域主要是程序运行到当前时刻的栈、寄存器和全局变量。 遍历灰色对象，将灰色对象引用的对象由白色 也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。 循环步骤3，直到灰色对象全部变黑色。重复以上操作 其中通过写屏障(write-barrier)【写屏障就是让goroutine与GC同时运行的手段，大大减少STW的时间，开启后指针传递时会把指针标记，本轮不回收，下轮GC时回收】检测对象有变化；还有一个辅助GC(mutator assist)机制【为防止内存分配过快，GC过程中，辅助GC线程并发运行，协助GC做一部分工作，先做一部分标记工作】， 收集所有白色对象（垃圾）。 插入写屏障 对象被引用时触发的机制（只在堆内存中生效）：赋值器这一行为通知给并发执行的回收器，被引用的对象标记为灰色 缺点：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活 删除写屏障 对象被删除时触发的机制（只在堆内存中生效）：赋值器将这一行为通知给并发执行的回收器，被删除的对象，如果自身为灰色或者白色，那么标记为灰色 缺点：一个对象的引用被删除后，即使没有其他存活的对象引用它，它仍然会活到下一轮，会产生很大冗余扫描成本，且降低了回收精度 混合写屏障 GC没有混合写屏障前，一直是插入写屏障；混合写屏障是插入写屏障 + 删除写屏障，写屏障只应用在堆上应用，栈上不启用（栈上启用成本很高） GC开始将栈上的对象全部扫描并标记为黑色。 GC期间，任何在栈上创建的新对象，均为黑色。 被删除的对象标记为灰色。 被添加的对象标记为灰色。 GC 的触发时机主动触发： 调用 runtime.GC() 方法，触发 GC 被动触发： 定时触发，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，触发 GC 根据内存分配阈值触发，该触发条件由环境变量GOGC控制，默认值为100（100%），当前堆内存占用是上次GC结束后占用内存的2倍时，触发GC","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"GC垃圾回收","slug":"GC垃圾回收","permalink":"https://asonemaster.github.io/tags/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}]},{"title":"go语言基础2——map相关","slug":"go3","date":"2022-08-18T03:23:59.890Z","updated":"2022-08-18T03:31:40.499Z","comments":true,"path":"2022/08/18/go3/","link":"","permalink":"https://asonemaster.github.io/2022/08/18/go3/","excerpt":"map 中删除一个 key，它的内存会释放么？两种情况： value元素为值类型时，不会释放内存 value元素为引用类型时，会释放内存，释放该元素类型所占内存 当map置为nil时，内存被回收 [（go垃圾回收)]([Go面试]Go GC实现原理?_哔哩哔哩_bilibili)","text":"map 中删除一个 key，它的内存会释放么？两种情况： value元素为值类型时，不会释放内存 value元素为引用类型时，会释放内存，释放该元素类型所占内存 当map置为nil时，内存被回收 [（go垃圾回收)]([Go面试]Go GC实现原理?_哔哩哔哩_bilibili) map 使用注意的点，是否并发安全？ 一定要先初始化，否则panic map类型(引用类型)是容易发生并发访问问题的。不注意就容易发生程序运行时并发读写导致的panic。 Go语言内建的map对象不是线程安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic。","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"map","slug":"map","permalink":"https://asonemaster.github.io/tags/map/"}]},{"title":"为什么代码中实例化结构体时大多要返回结构体指针 而不是结构体值","slug":"go2","date":"2022-08-17T07:58:17.300Z","updated":"2022-08-20T08:58:03.909Z","comments":true,"path":"2022/08/17/go2/","link":"","permalink":"https://asonemaster.github.io/2022/08/17/go2/","excerpt":"在学习 go 语言项目时，遇到这样一个问题： 通过struct结构体作为一个model，数据绑定等操作都是返回一个结构体指针，那么返回一个结构体变量，或者返回一个结构体指针，他们的区别是什么？ 因为二者都可以让我们生成我们所需要的结构体，那为什么还要去使用返回结构体指针呢？ 对于此疑问，我做了如下实验","text":"在学习 go 语言项目时，遇到这样一个问题： 通过struct结构体作为一个model，数据绑定等操作都是返回一个结构体指针，那么返回一个结构体变量，或者返回一个结构体指针，他们的区别是什么？ 因为二者都可以让我们生成我们所需要的结构体，那为什么还要去使用返回结构体指针呢？ 对于此疑问，我做了如下实验 // TableFile : 文件表结构体 type TableFile struct &#123; FileHash string FileName string FileSize string FileAddr string &#125; // GetFileMeta1 从mysql获取文件元信息 func GetFileMeta1(filehash1 string) *TableFile &#123; tfile1 := TableFile&#123;FileHash: filehash1&#125; fmt.Printf(\"GetFileMeta1函数内：%p\\n\", &amp;tfile1) return &amp;tfile1 &#125; // GetFileMeta2 从mysql获取文件元信息 func GetFileMeta2(filehash1 string) TableFile &#123; tfile2 := TableFile&#123;FileHash: filehash1&#125; fmt.Printf(\"GetFileMeta2函数内：%p\\n\", &amp;tfile2) return tfile2 &#125; // GetFileMeta3 从mysql获取文件元信息 func GetFileMeta3(filehash1 string) (tfile3 TableFile) &#123; tfile3 = TableFile&#123;FileHash: filehash1&#125; fmt.Printf(\"GetFileMeta3函数内：%p\\n\", &amp;tfile3) return &#125; func main() &#123; t1 := GetFileMeta1(\"1111\") fmt.Printf(\"GetFileMeta1 函数外%p\\n\", t1) t2 := GetFileMeta2(\"1111\") fmt.Printf(\"GetFileMeta2 函数外%p\\n\", &amp;t2) t3 := GetFileMeta3(\"1111\") fmt.Printf(\"GetFileMeta3 函数外%p\\n\", &amp;t3) &#125; //GetFileMeta1函数内：0xc00005a040 //GetFileMeta1 函数外0xc00005a040 //GetFileMeta2函数内：0xc00005a0c0 //GetFileMeta2 函数外0xc00005a080 //GetFileMeta3函数内：0xc00005a140 //GetFileMeta3 函数外0xc00005a100 这里可以发现： 使用指针结构体只分配了一次内存 使用结构体值却分配了两次 由于go是值拷贝模式，指针拷贝地址，没有分配多余内存；值拷贝数值，新的变量会重新分配地址给数值。 这一点了解了，可是我仍然不知道指针的性能提升在那里，虽然指针只分配了一次地址空间，可是该空间会分配在堆上发生内存逃逸，影响程序性能； 值空间虽然分配了两次空间，但函数内变量空间分配在栈上，函数结束，系统内核会自动销毁，不影响性能，？难道是多次分配调度内存空间，影响更大？ 返回结构体值与结构体指针性能问题: 传值 VS 传指针： 传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。 一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"指针","slug":"指针","permalink":"https://asonemaster.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"结构体","slug":"结构体","permalink":"https://asonemaster.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"}]},{"title":"go语言基础1——make和new","slug":"go1","date":"2022-08-17T05:16:20.029Z","updated":"2022-08-18T03:27:50.062Z","comments":true,"path":"2022/08/17/go1/","link":"","permalink":"https://asonemaster.github.io/2022/08/17/go1/","excerpt":"golang中make和new的区别共同点：都是给变量分配内存；不同点： 返回类型不同： new创建返回指针，指向分配类型的指针，分配的空间置为零，该类型的零值；make返回变量本身，分配空间后会进行初始； 分配类型：new可以为任意类型进行分配；make只能为slice，map，chan引用类型数据进行分配空间。 数组和切片的区别共同点：都是通过下标访问，并且都有容量长度； 不同点： 定义方式不同：数组必须指定大小，定义后不能增加容量和长度；切片不用，定义后切片数据增多，会自动扩容（当原切片长度小于1024时，新切片的容量会直接翻倍；超过1024会反复地增加25%，直到新容量超过所需要的容量）； 类型不同：数值为值类型；切片为引用类型，每个切片底层引用一个数组，所以切片扩容后，便会指向一个新的底层数组，内存地址跟着改变。","text":"golang中make和new的区别共同点：都是给变量分配内存；不同点： 返回类型不同： new创建返回指针，指向分配类型的指针，分配的空间置为零，该类型的零值；make返回变量本身，分配空间后会进行初始； 分配类型：new可以为任意类型进行分配；make只能为slice，map，chan引用类型数据进行分配空间。 数组和切片的区别共同点：都是通过下标访问，并且都有容量长度； 不同点： 定义方式不同：数组必须指定大小，定义后不能增加容量和长度；切片不用，定义后切片数据增多，会自动扩容（当原切片长度小于1024时，新切片的容量会直接翻倍；超过1024会反复地增加25%，直到新容量超过所需要的容量）； 类型不同：数值为值类型；切片为引用类型，每个切片底层引用一个数组，所以切片扩容后，便会指向一个新的底层数组，内存地址跟着改变。 for range 的时候它的地址会发生变化么？在 for a,b := range c 遍历中，a,b只会存一份地址，循环后会重新赋值，内存地址不变；因此for中创建协程后不要传入a或b的地址，可以再循环中通过创建临时变量解决。","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://asonemaster.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"切片","slug":"切片","permalink":"https://asonemaster.github.io/tags/%E5%88%87%E7%89%87/"}]},{"title":"golang学习路线，所需知识","slug":"golangStudy","date":"2022-08-17T01:50:07.335Z","updated":"2022-08-18T06:37:47.928Z","comments":true,"path":"2022/08/17/golangStudy/","link":"","permalink":"https://asonemaster.github.io/2022/08/17/golangStudy/","excerpt":"计算机基础1. 操作系统 了解进程、线程、协程的区别 了解进程间常用的通信方式 管道 命名管道（FIFO） 消息队列 信号量 共享内存 套接字（Socket） 了解5种网络IO模型 阻塞 IO（blocking IO） 非阻塞 IO（non-blocking IO） 多路复用 IO（IO multiplexing） 异步 IO（Asynchronous I/O） 信号驱动 IO（signal driven I/O， SIGIO）","text":"计算机基础1. 操作系统 了解进程、线程、协程的区别 了解进程间常用的通信方式 管道 命名管道（FIFO） 消息队列 信号量 共享内存 套接字（Socket） 了解5种网络IO模型 阻塞 IO（blocking IO） 非阻塞 IO（non-blocking IO） 多路复用 IO（IO multiplexing） 异步 IO（Asynchronous I/O） 信号驱动 IO（signal driven I/O， SIGIO） 了解并发与并行的区别 并发是指一个处理器同时处理多个任务。 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。 并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在， 并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。 了解同步与异步的区别 同步：同步是指一个进程在执行某个请求的时候，如果该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去。 异步：异步是指进程不需要一直等待下去，而是继续执行下面的操作，不管其他进程的状态，当有信息返回的时候会通知进程进行处理，这样就可以提高执行的效率了，即异步是我们发出的一个请求，该请求会在后台自动发出并获取数据，然后对数据进行处理，在此过程中，我们可以继续做其他操作，不管它怎么发出请求，不关心它怎么处理数据。 以上总结起来，通俗地讲，也就是说，同步需要按部就班地走完一整个流程，完成一整个动作，打个比方：同步的时候，你在写程序，然后你妈妈叫你马上拖地，你就必须停止写程序然后拖地，没法同时进行。而异步则不需要按部就班，可以在等待那个动作的时候同时做别的动作， 了解阻塞与非阻塞的区别 了解常见缓存淘汰算法： LRU（Least Recently Used）最近最少使用算法 LFU（Least Frequently Used）最近频次最少算法 FIFO（First In First Out）先入先出算法 ARC（Adjustable Replacement Cache）自适应缓存替换算法 2. 计算机网络 了解网络协议 了解序列化协议 了解七层体系结构 了解四层体系结构 3. 计算机组成原理（冯诺依曼体系）[了解]4. 数据结构与算法 了解时间/空间复杂度 熟悉常用数据结构字符串数组链表队列二叉树栈堆 熟悉常用算法双指针左右指针排序二叉查找递归回溯贪心动态规划 5. 互联网（Internet） 互联网是如何工作的 HTTP是什么 浏览器以及浏览器如何运作 域名是什么 hosting是什么 6. 数据库 关系型数据库Mysql NoSQLRedis Golang编程基础 字符串 常量 变量 类型 操作符 表达式 语句 错误处理 1. 代码组织2. 标准库 功能性neterrorsossynctime 输入输出型iofmtlog 3. 版本控制 Git Go编程进阶原理 map channel goroutine slice runtime GMPGCCGO反射测试 单元测试 压力测试 覆盖测试 性能测试 并发编程 goroutine调度 channel调度 锁 waitGroup context sync atomic 操作系统 数据结构与算法（熟练掌握）计算机原理与网络 缓存 数据库 设计模式 Linux 工程化微服务 Web框架 中间件","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang学习路线","slug":"golang学习路线","permalink":"https://asonemaster.github.io/tags/golang%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}]}],"categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"},{"name":"linux","slug":"linux","permalink":"https://asonemaster.github.io/categories/linux/"},{"name":"Mysql","slug":"Mysql","permalink":"https://asonemaster.github.io/categories/Mysql/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://asonemaster.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Redis","slug":"Redis","permalink":"https://asonemaster.github.io/categories/Redis/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://asonemaster.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"channel","slug":"channel","permalink":"https://asonemaster.github.io/tags/channel/"},{"name":"文档说明查询","slug":"文档说明查询","permalink":"https://asonemaster.github.io/tags/%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E%E6%9F%A5%E8%AF%A2/"},{"name":"索引","slug":"索引","permalink":"https://asonemaster.github.io/tags/%E7%B4%A2%E5%BC%95/"},{"name":"常用操作","slug":"常用操作","permalink":"https://asonemaster.github.io/tags/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"name":"defer","slug":"defer","permalink":"https://asonemaster.github.io/tags/defer/"},{"name":"TCP","slug":"TCP","permalink":"https://asonemaster.github.io/tags/TCP/"},{"name":"HTTP","slug":"HTTP","permalink":"https://asonemaster.github.io/tags/HTTP/"},{"name":"context","slug":"context","permalink":"https://asonemaster.github.io/tags/context/"},{"name":"数组","slug":"数组","permalink":"https://asonemaster.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"切片","slug":"切片","permalink":"https://asonemaster.github.io/tags/%E5%88%87%E7%89%87/"},{"name":"内存逃逸","slug":"内存逃逸","permalink":"https://asonemaster.github.io/tags/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/"},{"name":"goroutine","slug":"goroutine","permalink":"https://asonemaster.github.io/tags/goroutine/"},{"name":"概念","slug":"概念","permalink":"https://asonemaster.github.io/tags/%E6%A6%82%E5%BF%B5/"},{"name":"Mysql存储引擎","slug":"Mysql存储引擎","permalink":"https://asonemaster.github.io/tags/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"},{"name":"Channel","slug":"Channel","permalink":"https://asonemaster.github.io/tags/Channel/"},{"name":"GC垃圾回收","slug":"GC垃圾回收","permalink":"https://asonemaster.github.io/tags/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"map","slug":"map","permalink":"https://asonemaster.github.io/tags/map/"},{"name":"指针","slug":"指针","permalink":"https://asonemaster.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"结构体","slug":"结构体","permalink":"https://asonemaster.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"golang学习路线","slug":"golang学习路线","permalink":"https://asonemaster.github.io/tags/golang%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}]}