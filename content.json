{"meta":{"title":"迅的个人博客","subtitle":"","description":"","author":"asOneMaster","url":"https://AsOneMaster.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-08-17T04:13:22.000Z","updated":"2022-08-17T04:14:12.172Z","comments":true,"path":"categories/index.html","permalink":"https://asonemaster.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-08-17T04:13:30.000Z","updated":"2022-08-17T04:14:29.129Z","comments":true,"path":"tags/index.html","permalink":"https://asonemaster.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"go语言基础6--context相关","slug":"go9","date":"2022-08-22T08:38:05.118Z","updated":"2022-08-22T08:55:10.875Z","comments":true,"path":"2022/08/22/go9/","link":"","permalink":"https://asonemaster.github.io/2022/08/22/go9/","excerpt":"context 的使用，context是否并发安全（联动问题-&gt;多个协程的同时控制）？ Go 的 Context 的数据结构包含 Deadline，Done，Err，Value；它可以控制一组呈树状结构的goroutine，每个goroutine拥有相同的上下文。通过context包，可以非常方便地在请求goroutine之间传递请求数据、取消信号和超时信息。 type Context interface &#123; Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct&#123;&#125; Err() error Value(key interface&#123;&#125;) interface&#123;&#125; &#125; 基础的context接口只定义了4个方法，下面分别简要说明一下： Deadline 方法：可以获取设置的截止时间，返回值 deadline 是截止时间，到了这个时间，Context 会自动发起取消请求，返回值 ok 表示是否设置了截止时间。 Done 方法：返回一个只读的 channel ，类型为 struct{}。如果这个 chan 可以读取，说明已经发出了取消信号，可以做清理操作，然后退出协程，释放资源。 Err 方法：返回Context 被取消的原因。 Value 方法：获取 Context 上绑定的值，是一个键值对，通过 key 来获取对应的值。 最常用的是 Done 方法，在 Context 取消的时候，会关闭这个只读的 Channel，相当于发出了取消信号。","text":"context 的使用，context是否并发安全（联动问题-&gt;多个协程的同时控制）？ Go 的 Context 的数据结构包含 Deadline，Done，Err，Value；它可以控制一组呈树状结构的goroutine，每个goroutine拥有相同的上下文。通过context包，可以非常方便地在请求goroutine之间传递请求数据、取消信号和超时信息。 type Context interface &#123; Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct&#123;&#125; Err() error Value(key interface&#123;&#125;) interface&#123;&#125; &#125; 基础的context接口只定义了4个方法，下面分别简要说明一下： Deadline 方法：可以获取设置的截止时间，返回值 deadline 是截止时间，到了这个时间，Context 会自动发起取消请求，返回值 ok 表示是否设置了截止时间。 Done 方法：返回一个只读的 channel ，类型为 struct{}。如果这个 chan 可以读取，说明已经发出了取消信号，可以做清理操作，然后退出协程，释放资源。 Err 方法：返回Context 被取消的原因。 Value 方法：获取 Context 上绑定的值，是一个键值对，通过 key 来获取对应的值。 最常用的是 Done 方法，在 Context 取消的时候，会关闭这个只读的 Channel，相当于发出了取消信号。 其主要的应用 ： 1：上下文控制，2：多个 goroutine 之间的数据交互等，3：超时控制：到某个时间点超时，过多久超时。 Context的使用 我们可以使用 select+channel 来实现了部分协程的终止，但是如果我们想要同时取消多个协程怎么办呢？如果需要定时取消又怎么办呢？ package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) func main() &#123; var wg sync.WaitGroup ctx, stop := context.WithCancel(context.Background()) wg.Add(1) go func() &#123; defer wg.Done() worker(ctx) &#125;() time.Sleep(3*time.Second) //工作3秒 stop() //3秒后发出停止指令 context的停止函数 wg.Wait() &#125; func worker(ctx context.Context)&#123; for &#123; select &#123; case &lt;- ctx.Done(): fmt.Println(\"结束\") return default: fmt.Println(\"运行中...\") &#125; time.Sleep(1*time.Second) &#125; &#125; context是并发安全的，为什么呢？context包提供两种创建根context的方式： context.Backgroud() context.TODO() 又提供了四个函数基于父Context衍生，其中使用WithValue函数来衍生context并携带数据，每次调用WithValue函数都会基于当前context衍生一个新的子context，WithValue内部主要就是调用valueCtx类： valueCtx结构如下： type valueCtx struct &#123; Context key, val interface&#123;&#125; &#125; 1.2.3.4. valueCtx继承父Context，这种是采用匿名接口的继承实现方式，key,val用来存储携带的键值对。 通过上面的代码分析，可以看到添加键值对不是在原context结构体上直接添加，而是以此context作为父节点，重新创建一个新的valueCtx子节点，将键值对添加在子节点上，由此形成一条context链。 获取键值过程也是层层向上调用直到最终的根节点，中间要是找到了key就会返回，否会就会找到最终的emptyCtx返回nil。画个图表示一下： 总结：context添加的键值对是链式的，会不断衍生新的context，所以context本身是不可变的，因此是线程安全的。 参考文章：Go语言，并发控制神器之Context - 掘金 (juejin.cn) 参考文章： 面试官：Context携带数据是线程安全的吗？-51CTO.COM","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"context","slug":"context","permalink":"https://asonemaster.github.io/tags/context/"}]},{"title":"go语言基础5--切片与数组相关","slug":"go8","date":"2022-08-22T08:13:07.157Z","updated":"2022-08-22T08:39:27.136Z","comments":true,"path":"2022/08/22/go8/","link":"","permalink":"https://asonemaster.github.io/2022/08/22/go8/","excerpt":"slice 和 array的区别？（下级问题-&gt;slice底层与扩容机制） 数组的零值是元素类型的零值，切片的零值是 nil； 数组是固定长度，切片是可变长度； 数组是值类型，切片是引用类型。 slice的底层实现 slice 底层 是有 3 个字段的数据结构分为： array 数组 len 长度 cap 容量 指针指向数组的第一个该 slice 可访问的元素，这个元素并不一定是底层数组的第一个元素，长度是指 slice 中元素的个数，它不能超过 slice 的容量。 容量的大小通常是从 slice 底层数组的元素个数，什么意思呢举例： arr：=[]int{1,2,3,4} slice:=arr[1:3] —（即：{2，3，4}） slice的长度为3 容量为4（{1，2，3，4}为底层数组） Go 的内置函数 len 和 cap 用来返回 slice 的长度和容量。","text":"slice 和 array的区别？（下级问题-&gt;slice底层与扩容机制） 数组的零值是元素类型的零值，切片的零值是 nil； 数组是固定长度，切片是可变长度； 数组是值类型，切片是引用类型。 slice的底层实现 slice 底层 是有 3 个字段的数据结构分为： array 数组 len 长度 cap 容量 指针指向数组的第一个该 slice 可访问的元素，这个元素并不一定是底层数组的第一个元素，长度是指 slice 中元素的个数，它不能超过 slice 的容量。 容量的大小通常是从 slice 底层数组的元素个数，什么意思呢举例： arr：=[]int{1,2,3,4} slice:=arr[1:3] —（即：{2，3，4}） slice的长度为3 容量为4（{1，2，3，4}为底层数组） Go 的内置函数 len 和 cap 用来返回 slice 的长度和容量。 slice扩容机制容量1024前 每次扩容2倍，之后扩容1.25倍，一直到超过元素数量或者相等位置。 所以对于数量太大的切片来说，扩容很耗性能，因为每次扩容，切片都会重新分配内存空间，并将原切片的值复制给新切片，原切片被垃圾回收。 如果知道容量的话，一开始指定生成大容量切片较好。使用make语句 []byte{}和 string 的区别（深层次问题-&gt;数组与切片的区别）string是不可变的字节序列，[]byte{}是可变的字节序列，简单地说string是字节数组，[]byte{}是字节切片 string为UTF-8编码 这导致len不一定是字符串中的个数 而是字节数","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://asonemaster.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"切片","slug":"切片","permalink":"https://asonemaster.github.io/tags/%E5%88%87%E7%89%87/"}]},{"title":"逃逸分析能做什么？如何进行逃逸分析？","slug":"go7","date":"2022-08-20T08:56:32.976Z","updated":"2022-08-22T08:17:15.846Z","comments":true,"path":"2022/08/20/go7/","link":"","permalink":"https://asonemaster.github.io/2022/08/20/go7/","excerpt":"（上级垃圾回收 问题逻辑- 垃圾回收-&gt;逃逸分析-&gt;内存逃逸） 逃逸分析是什么：编译器决定内存分配位置的方式，就称之为逃逸分析(escape analysis)。逃逸分析由编译器完成，作用于编译阶段。 逃逸分析能做什么：可以了解程序哪些内存在栈上，哪些在堆上，从而优化减少垃圾回收提升性能。 如何进行逃逸分析：go语言可以使用go build -gcflags ‘-m -N -l’ test.go 的方式 查看编译结果中的逃逸情况 在堆上（heap）的就发生了逃逸 必然不会发生逃逸的情况： 指针被没有发生逃逸的变量引用 仅仅在函数被对变量进行取地址操作，没有将指针传出","text":"（上级垃圾回收 问题逻辑- 垃圾回收-&gt;逃逸分析-&gt;内存逃逸） 逃逸分析是什么：编译器决定内存分配位置的方式，就称之为逃逸分析(escape analysis)。逃逸分析由编译器完成，作用于编译阶段。 逃逸分析能做什么：可以了解程序哪些内存在栈上，哪些在堆上，从而优化减少垃圾回收提升性能。 如何进行逃逸分析：go语言可以使用go build -gcflags ‘-m -N -l’ test.go 的方式 查看编译结果中的逃逸情况 在堆上（heap）的就发生了逃逸 必然不会发生逃逸的情况： 指针被没有发生逃逸的变量引用 仅仅在函数被对变量进行取地址操作，没有将指针传出 一定逃逸 构造函数new/make 返回的指针变量一定逃逸 被已经逃逸指针变量引用指针，一定发生逃逸 指针类型是slice，map,chan 引用指针一定发生逃逸 Maybe 逃逸 将指针作为入参传给别的函数，这里看指针在被传入函数的处理过程，如果发生上边三种情况会逃逸，否则不会 传值 VS 传指针： 传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。 一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"内存逃逸","slug":"内存逃逸","permalink":"https://asonemaster.github.io/tags/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/"}]},{"title":"goroutine(协程)和线程是什么关系，goroutine是如何调度的？","slug":"go6","date":"2022-08-20T08:04:38.465Z","updated":"2022-08-22T08:17:30.066Z","comments":true,"path":"2022/08/20/go6/","link":"","permalink":"https://asonemaster.github.io/2022/08/20/go6/","excerpt":"（上级问题并发 问题逻辑- 并发机制-&gt;GMP-&gt;goroutine调度） goroutine(协程)和线程说线程之前，我们先说进程和线程的关系， 首先线程是进程的执行体，拥有一个执行入口，以及进程虚拟地址空间中分配的栈—包括用户栈和内核栈，操作系统会记录线程控制信息， 而线程会在获得cpu时间片信息后执行 ，cpu中栈指针、指令指针等寄存器都到切换到对应的线程； 而协程就是线程创建的执行体，其控制信息由线程记录，由于用户程序不能操作内核空间，所以只能给协程分配用户栈，而操作系统对这个信息一无所知。 总结：协程是一种”用户态线程”。 goroutine如何调度说到goroutine的调度就不得不提MPG（GMP）模型 M: 线程 P: 执行go协程运行所必需的资源，关联本地可运行G的队列 G: go协程","text":"（上级问题并发 问题逻辑- 并发机制-&gt;GMP-&gt;goroutine调度） goroutine(协程)和线程说线程之前，我们先说进程和线程的关系， 首先线程是进程的执行体，拥有一个执行入口，以及进程虚拟地址空间中分配的栈—包括用户栈和内核栈，操作系统会记录线程控制信息， 而线程会在获得cpu时间片信息后执行 ，cpu中栈指针、指令指针等寄存器都到切换到对应的线程； 而协程就是线程创建的执行体，其控制信息由线程记录，由于用户程序不能操作内核空间，所以只能给协程分配用户栈，而操作系统对这个信息一无所知。 总结：协程是一种”用户态线程”。 goroutine如何调度说到goroutine的调度就不得不提MPG（GMP）模型 M: 线程 P: 执行go协程运行所必需的资源，关联本地可运行G的队列 G: go协程 G，M，P的个数 M 的数据默认启动的时候是 10000，内核很难支持这么多线程数，所以整个限制客户忽略，M 一般不做设置，设置好 P，M 一般都是要大于 P。 P 的数量一般建议是逻辑 CPU 数量的 2 倍。——使用runtime.GOMAXPROCS() 变量数一般是cpu核数的2倍，具体看性能分析。 G 的个数理论上是无限制的，但是受内存限制。 一开始go创建时只有MG，多个M分担多个G的执行任务时（想象整体G是一个全局队列，多个M执行G时），就会因为频繁 加锁解锁（不能让其他线程执行到同一个G）而发生等待，影响并发性能。所以，使用P，p有一个本地队列，这样只要M关联到P，就可以直接运行队列中待执行的G，不用每次从全局队列中争抢了。 （注意一个问题：程序中主进程结束不管协程有没有运行完，都会结束，所以一般使用wg sync.WaitGroup wg.Add() go func(){ wg.Done} wg.Wait()） 总结GMP调度流程： 线程M想运行任务就需得获取 P，即与P关联。 然从 P 的本地队列(LRQ)获取 G 若LRQ中没有可运行的G，M 会尝试从全局队列(GRQ)拿一批G放到P的本地队列， 若全局队列也未找到可运行的G时候，M会随机从其他 P 的本地队列偷一半放到自己 P 的本地队列。 拿到可运行的G之后，M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。 Go如何有效控制Goroutine并发数量","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://asonemaster.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"goroutine","slug":"goroutine","permalink":"https://asonemaster.github.io/tags/goroutine/"}]},{"title":"go语言的并发机制","slug":"goRoutine","date":"2022-08-19T13:28:44.044Z","updated":"2022-08-19T14:51:18.028Z","comments":true,"path":"2022/08/19/goRoutine/","link":"","permalink":"https://asonemaster.github.io/2022/08/19/goRoutine/","excerpt":"","text":"go语言并发原理 Go不推荐用共享内存的方式传递数据，而推荐使用channel(或称“通道” )。channel主要用来在多个goroutine之间传递数据，并且还 会保证整个过程的并发安全性。不过，作为可选方法，Go依然提供了一些传统的同步方法 (比如互斥量、 条件变量等)。 Go的并发机制指的是用于支撑goroutine 和channel的底层原理，说到这个就不得不提go语言的调度模型，GMP。 GMP调度模型说起Go的线程实现模型,有3个必知的核心元素,它们支撑起了这个模型的主框架，简要说明如下： M: machine的缩写。一个M代表一个内核线程，或称“工作线程”。 P: processor的缩写。一个P代表执行一个Go代码片段所必需的资源(或称“上下文环境”)。 G: goroutine的缩写。一个G代表一 个Go代码片段。前者是对后者的一种封装。 .未完待续~~~","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://asonemaster.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"Redis基础1","slug":"redis1","date":"2022-08-19T13:12:39.632Z","updated":"2022-08-19T13:29:59.909Z","comments":true,"path":"2022/08/19/redis1/","link":"","permalink":"https://asonemaster.github.io/2022/08/19/redis1/","excerpt":"Redis是什么 Redis是基于内存运行的高性能 K-V 数据库 Redis存储位置 内存中，所以效率高 Redis的五种数据结构 String：Redis最基本的数据类型，一个键对应一个值，一个键值最大存储512MB set：是String字符串类型的无序集合，也不可重复 zset：是String类型的有序集合，也不可重复。有序集合中的每个元素都需要指定一个分数，根据分数对元素进行升序排序","text":"Redis是什么 Redis是基于内存运行的高性能 K-V 数据库 Redis存储位置 内存中，所以效率高 Redis的五种数据结构 String：Redis最基本的数据类型，一个键对应一个值，一个键值最大存储512MB set：是String字符串类型的无序集合，也不可重复 zset：是String类型的有序集合，也不可重复。有序集合中的每个元素都需要指定一个分数，根据分数对元素进行升序排序 hash：hash是一个键值对的集合，是一个String类型的field和value的映射表，适合用于存储对象 list：是redis的简单的字符串列表，按插入顺序排序 Redis应用场景（可以用来做什么） 可用于缓存，事件发布或订阅，高速队列等场景 众多语言都支持Redis，因为Redis交换数据快，在服务器中常用来存储一些需要频繁调取的数据，节省内存开销，也极大的提升了速度。 将一些热点数据存储到Redis中，要用的时候，直接从内存取，极大的提高了速度和节约了服务器的开销。 会话缓存（最常用） 消息队列（支付） 活动排行榜或计数 发布，订阅消息（消息通知） 商品列表，评论列表 为什么使用Redis 完全基于内存，数据存在内存中，绝大部分请求是纯粹的内存操作，非常快速，跟传统的磁盘文件数据存储相比，避免了通过磁盘IO读取到内存这部分的开销。 数据结构简单，对数据操作也简单。Redis中的数据结构是专门进行设计的，每种数据结构都有一种或多种数据结构来支持。Redis正是依赖这些灵活的数据结构，来提升读取和写入的性能。 采用单线程，省去了很多上下文切换的时间以及CPU消耗，不存在竞争条件，不用去考虑各种锁的问题，不存在加锁释放锁操作，也不会出现死锁而导致的性能消耗。 使用基于IO多路复用机制的线程模型，可以处理并发的链接。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://asonemaster.github.io/categories/Redis/"}],"tags":[{"name":"概念","slug":"概念","permalink":"https://asonemaster.github.io/tags/%E6%A6%82%E5%BF%B5/"}]},{"title":"为什么InnoDB存储引擎选择使用B+tree索引结构?","slug":"mysql2","date":"2022-08-18T07:28:53.900Z","updated":"2022-08-18T07:35:14.682Z","comments":true,"path":"2022/08/18/mysql2/","link":"","permalink":"https://asonemaster.github.io/2022/08/18/mysql2/","excerpt":"","text":"由于B+tree所有数据都在叶子节点，上层节点仅仅起到索引结构，相对于二叉树，层级更少，搜索效率更高！ 如图： 其他结构讲解，链接—-11. 进阶-索引-结构-Btree_哔哩哔哩_bilibili","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://asonemaster.github.io/categories/Mysql/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://asonemaster.github.io/tags/%E7%B4%A2%E5%BC%95/"},{"name":"Mysql存储引擎","slug":"Mysql存储引擎","permalink":"https://asonemaster.github.io/tags/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"}]},{"title":"Mysql进阶1——Mysql存储引擎与索引相关","slug":"mysql1","date":"2022-08-18T06:42:08.272Z","updated":"2022-08-18T07:37:45.025Z","comments":true,"path":"2022/08/18/mysql1/","link":"","permalink":"https://asonemaster.github.io/2022/08/18/mysql1/","excerpt":"MySql存储引擎Mysql体系结构 连接层 服务层 引擎层 存储层 什么是存储引擎 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。","text":"MySql存储引擎Mysql体系结构 连接层 服务层 引擎层 存储层 什么是存储引擎 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。 存储引擎 InnoDB ➢介绍： InnoDB是一种兼顾高可靠性和高性能的通用存储引擎,在MySQL 5.5之后, InnoDB是默认的MySQL存储引擎。 ➢特点： DML操作遵循ACID模型，支持事务; 行级锁，提高并发访问性能; 支持外键FOREIGN KEY约束,保证数据的完整性和正确性; ​ ➢文件： ​ xxx.ibd: xxx代表的是表名, innoDB引擎的每张表都会对应这样一个表空间文件, 存储该表的表结构(frm、 sdi) 、数据和索引。​ 参数: innpdb_ file_ per_ table ​ ➢逻辑存储结构： ​ TableSpece: 表空间 ​ | ​ segment: 段​ | ​ Extent:I 区[1M—一个区可以有64个页]​ | ​ Page: 页[16K]​ | ​ Row: 行 MyISAM ➢介绍 MyISAM是MySQL早期的默认存储引擎。 ➢特点 不支持事务,不支持外键 支持表锁，不支持行锁 访问速度快 ➢文件 xxx.sdi:存储表结构信息 XXX.MYD:存储数据 XXX.MYI:存储索引 Memory ➢介绍 Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。 ➢特点 内存存放 hash索引( 默认) ➢文件 xxx.sdi:存储表结构信息 MySql存储引擎特点总结： 存储引擎选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。 ​ ➢InnoDB ：是Mysql的默认存储引擎， 支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的-致 ​ 性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储 引擎是比较合适的选择。 ​ ➢MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那 ​ 么选择这个存储引擎是非常合适的。（现如今被NOSQL-MongoDB替代） ​ ➢MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表 ​ 无法缓存在内存中，而且无法保障数据的安全性。（现如今被NOSQL-Redis替代） Mysql索引（存储引擎层）什么是索引 索引(index)是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级的查找算法，这种数据结构就是索引。 简单的说，索引是一种数据结构，一种实现高级查找算法的数据结构。 索引结构MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构,主要包含以下几种: B+Tree —— 最常见的索引类型，大部分引擎都支持B+树索引 Hash —— 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询 R-tree(空间索引) —— 空间索引是MyISAM弓|擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-text(全文索引) —— 是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene，Solr，ES 索引结构与对应支持引擎","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://asonemaster.github.io/categories/Mysql/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://asonemaster.github.io/tags/%E7%B4%A2%E5%BC%95/"},{"name":"Mysql存储引擎","slug":"Mysql存储引擎","permalink":"https://asonemaster.github.io/tags/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"}]},{"title":"go语言基础4——Channel相关","slug":"go5","date":"2022-08-18T03:31:24.180Z","updated":"2022-08-20T06:12:04.779Z","comments":true,"path":"2022/08/18/go5/","link":"","permalink":"https://asonemaster.github.io/2022/08/18/go5/","excerpt":"channel 是否线程安全？锁用在什么地方？ Golang的Channel,发送一个数据到Channel 和 从Channel接收一个数据都是原子性的。 如果把线程安全定义为允许多个goroutine同时去读写，那么golang 的channel 是线程安全的，因为channel底层数据结构中是带有lock的，不需要在并发读写同一个channe时再加锁。 而且Go的设计思想就是：不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁（共享内存通信），后者就是Channel。 也就是说，设计Channel的主要目的就是在多任务间传递数据的，这当然是安全的 go channel 的底层实现原理 （数据结构）总结hchan结构体的主要组成部分有四个： 用来保存goroutine之间传递数据的循环数组：buf 用来记录此循环数组当前发送或接收数据的下标值：sendx（发送队列）和recvx（接受队列） 用于保存向该chan发送和从该chan接收数据被阻塞的goroutine队列： sendq 和 recvq 保证channel写入和读取数据时线程安全的锁：lock","text":"channel 是否线程安全？锁用在什么地方？ Golang的Channel,发送一个数据到Channel 和 从Channel接收一个数据都是原子性的。 如果把线程安全定义为允许多个goroutine同时去读写，那么golang 的channel 是线程安全的，因为channel底层数据结构中是带有lock的，不需要在并发读写同一个channe时再加锁。 而且Go的设计思想就是：不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁（共享内存通信），后者就是Channel。 也就是说，设计Channel的主要目的就是在多任务间传递数据的，这当然是安全的 go channel 的底层实现原理 （数据结构）总结hchan结构体的主要组成部分有四个： 用来保存goroutine之间传递数据的循环数组：buf 用来记录此循环数组当前发送或接收数据的下标值：sendx（发送队列）和recvx（接受队列） 用于保存向该chan发送和从该chan接收数据被阻塞的goroutine队列： sendq 和 recvq 保证channel写入和读取数据时线程安全的锁：lock go channel为什么设计成线程安全？不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全 如何实现线程安全的？channel的底层实现中，hchan结构体中采用Mutex（互斥）锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据 nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？ 读写值 nil 管道会永久阻塞 关闭的管道读数据仍然可以读数据 往关闭的管道写数据会 panic 关闭为 nil 的管道会 panic 关闭已经关闭的管道 panic 总结：对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。如果我们试图关闭一个已经关闭了的通道，也会引发 panic。 使用场景： 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Channel","slug":"Channel","permalink":"https://asonemaster.github.io/tags/Channel/"}]},{"title":"go语言基础3——GC相关","slug":"go4","date":"2022-08-18T03:28:55.755Z","updated":"2022-08-18T03:30:39.791Z","comments":true,"path":"2022/08/18/go4/","link":"","permalink":"https://asonemaster.github.io/2022/08/18/go4/","excerpt":"什么是GC垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。 堆内存上分配的数据对象，不会再使用时，不会自动释放内存，就变成垃圾，在程序的运行过程中，如果不能及时清理，会导致越来越多的内存空间被浪费，导致系统性能下降。 因此需要内存回收，内存回收分为两种方式: 手动释放占用内存空间 可能会出现的问题：悬挂指针： 释放的早了，后续对数据的访问就会出错，因为对应的内存空间可能已经清空，重新分配，甚至是归还给操作系统了。内存泄漏： 如果忘了释放，一直占用内存，导致内存泄漏。 自动内存回收 程序自动检测对象决定是否要回收其内存。 核心思想：程序中用得到的数据，一定是可以从栈或数据段这些根节点追踪得到的数据，追踪不到的数据，肯定用不到，也就是垃圾。","text":"什么是GC垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。 堆内存上分配的数据对象，不会再使用时，不会自动释放内存，就变成垃圾，在程序的运行过程中，如果不能及时清理，会导致越来越多的内存空间被浪费，导致系统性能下降。 因此需要内存回收，内存回收分为两种方式: 手动释放占用内存空间 可能会出现的问题：悬挂指针： 释放的早了，后续对数据的访问就会出错，因为对应的内存空间可能已经清空，重新分配，甚至是归还给操作系统了。内存泄漏： 如果忘了释放，一直占用内存，导致内存泄漏。 自动内存回收 程序自动检测对象决定是否要回收其内存。 核心思想：程序中用得到的数据，一定是可以从栈或数据段这些根节点追踪得到的数据，追踪不到的数据，肯定用不到，也就是垃圾。 go gc 是怎么实现的？ 一次完整的垃圾回收会分为四个阶段，分别是标记准备、标记开始、标记终止、清理： 标记准备（Mark Setup）：打开写屏障（Write Barrier），需 STW（stop the world) 标记开始（Marking）：使用三色标记法并发标记 ，与用户程序并发执行 标记终止（Mark Termination）：对触发写屏障的对象进行重新扫描标记，关闭写屏障（Write Barrier），需 STW（stop the world) 清理（Sweeping）：将需要回收的内存归还到堆中，将过多的内存归还给操作系统，与用户程序并发执行 GC机制随着golang版本变化如何变化的？ go 1.3 之前采用标记清除法，需要STWgo 1.5 采用三色标记法，插入写屏障机制（只在堆内存中生效），最后仍需对栈内存进行STWgo 1.8 采用混合写屏障机制**，屏障限制只在堆内存中生效。避免了最后节点对栈进行STW的问题，提升了GC效率 一个概念：STW：stop the word，指程序执行过程中，中断暂停程序逻辑，专门去进行垃圾回收。（STW目的是为了防止GC扫描时内存变化引起的混乱） 标记清除法 从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。 开启STW， 从根节点出发，标记所有可达对象 停止STW，然后回收所有未标记的对象。 优点：解决了引用计数的缺点。 缺点：需要 STW，暂时停掉程序运行。 三色标记法【改进的标记清除法】+写屏障机制的流程 三色标记法是对标记阶段的改进，原理如下： 初始状态所有对象都是白色。 从root根出发扫描所有根对象（下图a,b），将他们引用的对象标记为灰色（图中A，B） 那么什么是root呢？ 看了很多文章都没解释这这个概念，在这儿说明下：root区域主要是程序运行到当前时刻的栈、寄存器和全局变量。 遍历灰色对象，将灰色对象引用的对象由白色 也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。 循环步骤3，直到灰色对象全部变黑色。重复以上操作 其中通过写屏障(write-barrier)【写屏障就是让goroutine与GC同时运行的手段，大大减少STW的时间，开启后指针传递时会把指针标记，本轮不回收，下轮GC时回收】检测对象有变化；还有一个辅助GC(mutator assist)机制【为防止内存分配过快，GC过程中，辅助GC线程并发运行，协助GC做一部分工作，先做一部分标记工作】， 收集所有白色对象（垃圾）。 插入写屏障 对象被引用时触发的机制（只在堆内存中生效）：赋值器这一行为通知给并发执行的回收器，被引用的对象标记为灰色 缺点：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活 删除写屏障 对象被删除时触发的机制（只在堆内存中生效）：赋值器将这一行为通知给并发执行的回收器，被删除的对象，如果自身为灰色或者白色，那么标记为灰色 缺点：一个对象的引用被删除后，即使没有其他存活的对象引用它，它仍然会活到下一轮，会产生很大冗余扫描成本，且降低了回收精度 混合写屏障 GC没有混合写屏障前，一直是插入写屏障；混合写屏障是插入写屏障 + 删除写屏障，写屏障只应用在堆上应用，栈上不启用（栈上启用成本很高） GC开始将栈上的对象全部扫描并标记为黑色。 GC期间，任何在栈上创建的新对象，均为黑色。 被删除的对象标记为灰色。 被添加的对象标记为灰色。 GC 的触发时机主动触发： 调用 runtime.GC() 方法，触发 GC 被动触发： 定时触发，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，触发 GC 根据内存分配阈值触发，该触发条件由环境变量GOGC控制，默认值为100（100%），当前堆内存占用是上次GC结束后占用内存的2倍时，触发GC","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"GC垃圾回收","slug":"GC垃圾回收","permalink":"https://asonemaster.github.io/tags/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}]},{"title":"go语言基础2——map相关","slug":"go3","date":"2022-08-18T03:23:59.890Z","updated":"2022-08-18T03:31:40.499Z","comments":true,"path":"2022/08/18/go3/","link":"","permalink":"https://asonemaster.github.io/2022/08/18/go3/","excerpt":"map 中删除一个 key，它的内存会释放么？两种情况： value元素为值类型时，不会释放内存 value元素为引用类型时，会释放内存，释放该元素类型所占内存 当map置为nil时，内存被回收 [（go垃圾回收)]([Go面试]Go GC实现原理?_哔哩哔哩_bilibili)","text":"map 中删除一个 key，它的内存会释放么？两种情况： value元素为值类型时，不会释放内存 value元素为引用类型时，会释放内存，释放该元素类型所占内存 当map置为nil时，内存被回收 [（go垃圾回收)]([Go面试]Go GC实现原理?_哔哩哔哩_bilibili) map 使用注意的点，是否并发安全？ 一定要先初始化，否则panic map类型(引用类型)是容易发生并发访问问题的。不注意就容易发生程序运行时并发读写导致的panic。 Go语言内建的map对象不是线程安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic。","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"map","slug":"map","permalink":"https://asonemaster.github.io/tags/map/"}]},{"title":"为什么代码中实例化结构体时大多要返回结构体指针 而不是结构体值","slug":"go2","date":"2022-08-17T07:58:17.300Z","updated":"2022-08-20T08:58:03.909Z","comments":true,"path":"2022/08/17/go2/","link":"","permalink":"https://asonemaster.github.io/2022/08/17/go2/","excerpt":"在学习 go 语言项目时，遇到这样一个问题： 通过struct结构体作为一个model，数据绑定等操作都是返回一个结构体指针，那么返回一个结构体变量，或者返回一个结构体指针，他们的区别是什么？ 因为二者都可以让我们生成我们所需要的结构体，那为什么还要去使用返回结构体指针呢？ 对于此疑问，我做了如下实验","text":"在学习 go 语言项目时，遇到这样一个问题： 通过struct结构体作为一个model，数据绑定等操作都是返回一个结构体指针，那么返回一个结构体变量，或者返回一个结构体指针，他们的区别是什么？ 因为二者都可以让我们生成我们所需要的结构体，那为什么还要去使用返回结构体指针呢？ 对于此疑问，我做了如下实验 // TableFile : 文件表结构体 type TableFile struct &#123; FileHash string FileName string FileSize string FileAddr string &#125; // GetFileMeta1 从mysql获取文件元信息 func GetFileMeta1(filehash1 string) *TableFile &#123; tfile1 := TableFile&#123;FileHash: filehash1&#125; fmt.Printf(\"GetFileMeta1函数内：%p\\n\", &amp;tfile1) return &amp;tfile1 &#125; // GetFileMeta2 从mysql获取文件元信息 func GetFileMeta2(filehash1 string) TableFile &#123; tfile2 := TableFile&#123;FileHash: filehash1&#125; fmt.Printf(\"GetFileMeta2函数内：%p\\n\", &amp;tfile2) return tfile2 &#125; // GetFileMeta3 从mysql获取文件元信息 func GetFileMeta3(filehash1 string) (tfile3 TableFile) &#123; tfile3 = TableFile&#123;FileHash: filehash1&#125; fmt.Printf(\"GetFileMeta3函数内：%p\\n\", &amp;tfile3) return &#125; func main() &#123; t1 := GetFileMeta1(\"1111\") fmt.Printf(\"GetFileMeta1 函数外%p\\n\", t1) t2 := GetFileMeta2(\"1111\") fmt.Printf(\"GetFileMeta2 函数外%p\\n\", &amp;t2) t3 := GetFileMeta3(\"1111\") fmt.Printf(\"GetFileMeta3 函数外%p\\n\", &amp;t3) &#125; //GetFileMeta1函数内：0xc00005a040 //GetFileMeta1 函数外0xc00005a040 //GetFileMeta2函数内：0xc00005a0c0 //GetFileMeta2 函数外0xc00005a080 //GetFileMeta3函数内：0xc00005a140 //GetFileMeta3 函数外0xc00005a100 这里可以发现： 使用指针结构体只分配了一次内存 使用结构体值却分配了两次 由于go是值拷贝模式，指针拷贝地址，没有分配多余内存；值拷贝数值，新的变量会重新分配地址给数值。 这一点了解了，可是我仍然不知道指针的性能提升在那里，虽然指针只分配了一次地址空间，可是该空间会分配在堆上发生内存逃逸，影响程序性能； 值空间虽然分配了两次空间，但函数内变量空间分配在栈上，函数结束，系统内核会自动销毁，不影响性能，？难道是多次分配调度内存空间，影响更大？ 返回结构体值与结构体指针性能问题: 传值 VS 传指针： 传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。 一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"指针","slug":"指针","permalink":"https://asonemaster.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"结构体","slug":"结构体","permalink":"https://asonemaster.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"}]},{"title":"go语言基础1——make和new","slug":"go1","date":"2022-08-17T05:16:20.029Z","updated":"2022-08-18T03:27:50.062Z","comments":true,"path":"2022/08/17/go1/","link":"","permalink":"https://asonemaster.github.io/2022/08/17/go1/","excerpt":"golang中make和new的区别共同点：都是给变量分配内存；不同点： 返回类型不同： new创建返回指针，指向分配类型的指针，分配的空间置为零，该类型的零值；make返回变量本身，分配空间后会进行初始； 分配类型：new可以为任意类型进行分配；make只能为slice，map，chan引用类型数据进行分配空间。 数组和切片的区别共同点：都是通过下标访问，并且都有容量长度； 不同点： 定义方式不同：数组必须指定大小，定义后不能增加容量和长度；切片不用，定义后切片数据增多，会自动扩容（当原切片长度小于1024时，新切片的容量会直接翻倍；超过1024会反复地增加25%，直到新容量超过所需要的容量）； 类型不同：数值为值类型；切片为引用类型，每个切片底层引用一个数组，所以切片扩容后，便会指向一个新的底层数组，内存地址跟着改变。","text":"golang中make和new的区别共同点：都是给变量分配内存；不同点： 返回类型不同： new创建返回指针，指向分配类型的指针，分配的空间置为零，该类型的零值；make返回变量本身，分配空间后会进行初始； 分配类型：new可以为任意类型进行分配；make只能为slice，map，chan引用类型数据进行分配空间。 数组和切片的区别共同点：都是通过下标访问，并且都有容量长度； 不同点： 定义方式不同：数组必须指定大小，定义后不能增加容量和长度；切片不用，定义后切片数据增多，会自动扩容（当原切片长度小于1024时，新切片的容量会直接翻倍；超过1024会反复地增加25%，直到新容量超过所需要的容量）； 类型不同：数值为值类型；切片为引用类型，每个切片底层引用一个数组，所以切片扩容后，便会指向一个新的底层数组，内存地址跟着改变。 for range 的时候它的地址会发生变化么？在 for a,b := range c 遍历中，a,b只会存一份地址，循环后会重新赋值，内存地址不变；因此for中创建协程后不要传入a或b的地址，可以再循环中通过创建临时变量解决。","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://asonemaster.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"切片","slug":"切片","permalink":"https://asonemaster.github.io/tags/%E5%88%87%E7%89%87/"}]},{"title":"golang学习路线，所需知识","slug":"golangStudy","date":"2022-08-17T01:50:07.335Z","updated":"2022-08-18T06:37:47.928Z","comments":true,"path":"2022/08/17/golangStudy/","link":"","permalink":"https://asonemaster.github.io/2022/08/17/golangStudy/","excerpt":"计算机基础1. 操作系统 了解进程、线程、协程的区别 了解进程间常用的通信方式 管道 命名管道（FIFO） 消息队列 信号量 共享内存 套接字（Socket） 了解5种网络IO模型 阻塞 IO（blocking IO） 非阻塞 IO（non-blocking IO） 多路复用 IO（IO multiplexing） 异步 IO（Asynchronous I/O） 信号驱动 IO（signal driven I/O， SIGIO）","text":"计算机基础1. 操作系统 了解进程、线程、协程的区别 了解进程间常用的通信方式 管道 命名管道（FIFO） 消息队列 信号量 共享内存 套接字（Socket） 了解5种网络IO模型 阻塞 IO（blocking IO） 非阻塞 IO（non-blocking IO） 多路复用 IO（IO multiplexing） 异步 IO（Asynchronous I/O） 信号驱动 IO（signal driven I/O， SIGIO） 了解并发与并行的区别 并发是指一个处理器同时处理多个任务。 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。 并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在， 并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。 了解同步与异步的区别 同步：同步是指一个进程在执行某个请求的时候，如果该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去。 异步：异步是指进程不需要一直等待下去，而是继续执行下面的操作，不管其他进程的状态，当有信息返回的时候会通知进程进行处理，这样就可以提高执行的效率了，即异步是我们发出的一个请求，该请求会在后台自动发出并获取数据，然后对数据进行处理，在此过程中，我们可以继续做其他操作，不管它怎么发出请求，不关心它怎么处理数据。 以上总结起来，通俗地讲，也就是说，同步需要按部就班地走完一整个流程，完成一整个动作，打个比方：同步的时候，你在写程序，然后你妈妈叫你马上拖地，你就必须停止写程序然后拖地，没法同时进行。而异步则不需要按部就班，可以在等待那个动作的时候同时做别的动作， 了解阻塞与非阻塞的区别 了解常见缓存淘汰算法： LRU（Least Recently Used）最近最少使用算法 LFU（Least Frequently Used）最近频次最少算法 FIFO（First In First Out）先入先出算法 ARC（Adjustable Replacement Cache）自适应缓存替换算法 2. 计算机网络 了解网络协议 了解序列化协议 了解七层体系结构 了解四层体系结构 3. 计算机组成原理（冯诺依曼体系）[了解]4. 数据结构与算法 了解时间/空间复杂度 熟悉常用数据结构字符串数组链表队列二叉树栈堆 熟悉常用算法双指针左右指针排序二叉查找递归回溯贪心动态规划 5. 互联网（Internet） 互联网是如何工作的 HTTP是什么 浏览器以及浏览器如何运作 域名是什么 hosting是什么 6. 数据库 关系型数据库Mysql NoSQLRedis Golang编程基础 字符串 常量 变量 类型 操作符 表达式 语句 错误处理 1. 代码组织2. 标准库 功能性neterrorsossynctime 输入输出型iofmtlog 3. 版本控制 Git Go编程进阶原理 map channel goroutine slice runtime GMPGCCGO反射测试 单元测试 压力测试 覆盖测试 性能测试 并发编程 goroutine调度 channel调度 锁 waitGroup context sync atomic 操作系统 数据结构与算法（熟练掌握）计算机原理与网络 缓存 数据库 设计模式 Linux 工程化微服务 Web框架 中间件","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang学习路线","slug":"golang学习路线","permalink":"https://asonemaster.github.io/tags/golang%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}]}],"categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"},{"name":"Redis","slug":"Redis","permalink":"https://asonemaster.github.io/categories/Redis/"},{"name":"Mysql","slug":"Mysql","permalink":"https://asonemaster.github.io/categories/Mysql/"}],"tags":[{"name":"context","slug":"context","permalink":"https://asonemaster.github.io/tags/context/"},{"name":"数组","slug":"数组","permalink":"https://asonemaster.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"切片","slug":"切片","permalink":"https://asonemaster.github.io/tags/%E5%88%87%E7%89%87/"},{"name":"内存逃逸","slug":"内存逃逸","permalink":"https://asonemaster.github.io/tags/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/"},{"name":"并发","slug":"并发","permalink":"https://asonemaster.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"goroutine","slug":"goroutine","permalink":"https://asonemaster.github.io/tags/goroutine/"},{"name":"概念","slug":"概念","permalink":"https://asonemaster.github.io/tags/%E6%A6%82%E5%BF%B5/"},{"name":"索引","slug":"索引","permalink":"https://asonemaster.github.io/tags/%E7%B4%A2%E5%BC%95/"},{"name":"Mysql存储引擎","slug":"Mysql存储引擎","permalink":"https://asonemaster.github.io/tags/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"},{"name":"Channel","slug":"Channel","permalink":"https://asonemaster.github.io/tags/Channel/"},{"name":"GC垃圾回收","slug":"GC垃圾回收","permalink":"https://asonemaster.github.io/tags/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"map","slug":"map","permalink":"https://asonemaster.github.io/tags/map/"},{"name":"指针","slug":"指针","permalink":"https://asonemaster.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"结构体","slug":"结构体","permalink":"https://asonemaster.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"golang学习路线","slug":"golang学习路线","permalink":"https://asonemaster.github.io/tags/golang%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}]}