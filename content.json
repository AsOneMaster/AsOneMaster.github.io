{"meta":{"title":"迅的个人博客","subtitle":"","description":"","author":"asOneMaster","url":"https://AsOneMaster.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-08-17T04:13:22.000Z","updated":"2022-08-17T04:14:12.172Z","comments":true,"path":"categories/index.html","permalink":"https://asonemaster.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-08-17T04:13:30.000Z","updated":"2022-08-17T04:14:29.129Z","comments":true,"path":"tags/index.html","permalink":"https://asonemaster.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"test","slug":"test","date":"2022-08-17T09:44:48.000Z","updated":"2022-08-17T09:44:48.672Z","comments":true,"path":"2022/08/17/test/","link":"","permalink":"https://asonemaster.github.io/2022/08/17/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"为什么代码中实例化结构体时大多要返回结构体指针 而不是结构体值","slug":"goBase2","date":"2022-08-17T07:58:17.300Z","updated":"2022-08-17T08:38:51.356Z","comments":true,"path":"2022/08/17/goBase2/","link":"","permalink":"https://asonemaster.github.io/2022/08/17/goBase2/","excerpt":"在学习 go 语言项目时，遇到这样一个问题： 通过struct结构体作为一个model，数据绑定等操作都是返回一个结构体指针，那么返回一个结构体变量，或者返回一个结构体指针，他们的区别是什么？ 因为二者都可以让我们生成我们所需要的结构体，那为什么还要去使用返回结构体指针呢？ 对于此疑问，我做了如下实验","text":"在学习 go 语言项目时，遇到这样一个问题： 通过struct结构体作为一个model，数据绑定等操作都是返回一个结构体指针，那么返回一个结构体变量，或者返回一个结构体指针，他们的区别是什么？ 因为二者都可以让我们生成我们所需要的结构体，那为什么还要去使用返回结构体指针呢？ 对于此疑问，我做了如下实验 // TableFile : 文件表结构体 type TableFile struct &#123; FileHash string FileName string FileSize string FileAddr string &#125; // GetFileMeta1 从mysql获取文件元信息 func GetFileMeta1(filehash1 string) *TableFile &#123; tfile1 := TableFile&#123;FileHash: filehash1&#125; fmt.Printf(\"GetFileMeta1函数内：%p\\n\", &amp;tfile1) return &amp;tfile1 &#125; // GetFileMeta2 从mysql获取文件元信息 func GetFileMeta2(filehash1 string) TableFile &#123; tfile2 := TableFile&#123;FileHash: filehash1&#125; fmt.Printf(\"GetFileMeta2函数内：%p\\n\", &amp;tfile2) return tfile2 &#125; // GetFileMeta3 从mysql获取文件元信息 func GetFileMeta3(filehash1 string) (tfile3 TableFile) &#123; tfile3 = TableFile&#123;FileHash: filehash1&#125; fmt.Printf(\"GetFileMeta3函数内：%p\\n\", &amp;tfile3) return &#125; func main() &#123; t1 := GetFileMeta1(\"1111\") fmt.Printf(\"GetFileMeta1 函数外%p\\n\", t1) t2 := GetFileMeta2(\"1111\") fmt.Printf(\"GetFileMeta2 函数外%p\\n\", &amp;t2) t3 := GetFileMeta3(\"1111\") fmt.Printf(\"GetFileMeta3 函数外%p\\n\", &amp;t3) &#125; //GetFileMeta1函数内：0xc00005a040 //GetFileMeta1 函数外0xc00005a040 //GetFileMeta2函数内：0xc00005a0c0 //GetFileMeta2 函数外0xc00005a080 //GetFileMeta3函数内：0xc00005a140 //GetFileMeta3 函数外0xc00005a100 这里可以发现： 使用指针结构体只分配了一次内存 使用结构体值却分配了两次 由于go是值拷贝模式，指针拷贝地址，没有分配多余内存；值拷贝数值，新的变量会重新分配地址给数值。 这一点了解了，可是我仍然不知道指针的性能提升在那里，虽然指针只分配了一次地址空间，可是该空间会分配在堆上发生内存逃逸，影响程序性能； 值空间虽然分配了两次空间，但函数内变量空间分配在栈上，函数结束，系统内核会自动销毁，不影响性能，？难道是多次分配调度内存空间，影响更大？ 返回结构体值与结构体指针性能问题","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"指针","slug":"指针","permalink":"https://asonemaster.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"结构体","slug":"结构体","permalink":"https://asonemaster.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"}]},{"title":"go语言基础1","slug":"goBase","date":"2022-08-17T05:16:20.029Z","updated":"2022-08-17T08:00:54.347Z","comments":true,"path":"2022/08/17/goBase/","link":"","permalink":"https://asonemaster.github.io/2022/08/17/goBase/","excerpt":"golang中make和new的区别共同点：都是给变量分配内存；不同点： 返回类型不同： new创建返回指针，指向分配类型的指针，分配的空间置为零，该类型的零值；make返回变量本身，分配空间后会进行初始； 分配类型：new可以为任意类型进行分配；make只能为slice，map，chan引用类型数据进行分配空间。 数组和切片的区别共同点：都是通过下标访问，并且都有容量长度； 不同点： 定义方式不同：数组必须指定大小，定义后不能增加容量和长度；切片不用，定义后切片数据增多，会自动扩容（当原切片长度小于1024时，新切片的容量会直接翻倍；超过1024会反复地增加25%，直到新容量超过所需要的容量）； 类型不同：数值为值类型；切片为引用类型，每个切片底层引用一个数组，所以切片扩容后，便会指向一个新的底层数组，内存地址跟着改变。","text":"golang中make和new的区别共同点：都是给变量分配内存；不同点： 返回类型不同： new创建返回指针，指向分配类型的指针，分配的空间置为零，该类型的零值；make返回变量本身，分配空间后会进行初始； 分配类型：new可以为任意类型进行分配；make只能为slice，map，chan引用类型数据进行分配空间。 数组和切片的区别共同点：都是通过下标访问，并且都有容量长度； 不同点： 定义方式不同：数组必须指定大小，定义后不能增加容量和长度；切片不用，定义后切片数据增多，会自动扩容（当原切片长度小于1024时，新切片的容量会直接翻倍；超过1024会反复地增加25%，直到新容量超过所需要的容量）； 类型不同：数值为值类型；切片为引用类型，每个切片底层引用一个数组，所以切片扩容后，便会指向一个新的底层数组，内存地址跟着改变。 for range 的时候它的地址会发生变化么？在 for a,b := range c 遍历中，a,b只会存一份地址，循环后会重新赋值，内存地址不变；因此for中创建协程后不要传入a或b的地址，可以再循环中通过创建临时变量解决。","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://asonemaster.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"切片","slug":"切片","permalink":"https://asonemaster.github.io/tags/%E5%88%87%E7%89%87/"}]},{"title":"golang学习路线，所需知识","slug":"golangStudy","date":"2022-08-17T01:50:07.335Z","updated":"2022-08-17T09:30:02.701Z","comments":true,"path":"2022/08/17/golangStudy/","link":"","permalink":"https://asonemaster.github.io/2022/08/17/golangStudy/","excerpt":"计算机基础1. 操作系统 了解进程、线程、协程的区别 了解进程间常用的通信方式 管道 命名管道（FIFO） 消息队列 信号量 共享内存 套接字（Socket） 了解5种网络IO模型 阻塞 IO（blocking IO） 非阻塞 IO（non-blocking IO） 多路复用 IO（IO multiplexing） 异步 IO（Asynchronous I/O） 信号驱动 IO（signal driven I/O， SIGIO）","text":"计算机基础1. 操作系统 了解进程、线程、协程的区别 了解进程间常用的通信方式 管道 命名管道（FIFO） 消息队列 信号量 共享内存 套接字（Socket） 了解5种网络IO模型 阻塞 IO（blocking IO） 非阻塞 IO（non-blocking IO） 多路复用 IO（IO multiplexing） 异步 IO（Asynchronous I/O） 信号驱动 IO（signal driven I/O， SIGIO） 了解并发与并行的区别 并发是指一个处理器同时处理多个任务。 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。 并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在， 并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。 了解同步与异步的区别 同步：同步是指一个进程在执行某个请求的时候，如果该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去。 异步：异步是指进程不需要一直等待下去，而是继续执行下面的操作，不管其他进程的状态，当有信息返回的时候会通知进程进行处理，这样就可以提高执行的效率了，即异步是我们发出的一个请求，该请求会在后台自动发出并获取数据，然后对数据进行处理，在此过程中，我们可以继续做其他操作，不管它怎么发出请求，不关心它怎么处理数据。 以上总结起来，通俗地讲，也就是说，同步需要按部就班地走完一整个流程，完成一整个动作，打个比方：同步的时候，你在写程序，然后你妈妈叫你马上拖地，你就必须停止写程序然后拖地，没法同时进行。而异步则不需要按部就班，可以在等待那个动作的时候同时做别的动作， 了解阻塞与非阻塞的区别 了解常见缓存淘汰算法： LRU（Least Recently Used）最近最少使用算法 LFU（Least Frequently Used）最近频次最少算法 FIFO（First In First Out）先入先出算法 ARC（Adjustable Replacement Cache）自适应缓存替换算法 2. 计算机网络 了解网络协议 了解序列化协议 了解七层体系结构 了解四层体系结构 3. 计算机组成原理（冯诺依曼体系）[了解]4. 数据结构与算法 了解时间/空间复杂度 熟悉常用数据结构字符串数组链表队列二叉树栈堆 熟悉常用算法双指针左右指针排序二叉查找递归回溯贪心动态规划 5. 互联网（Internet） 互联网是如何工作的 HTTP是什么 浏览器以及浏览器如何运作 域名是什么 hosting是什么 6. 数据库 关系型数据库Mysql NoSQLRedis Golang编程基础 字符串 常量 变量 类型 操作符 表达式 语句 错误处理 1. 代码组织2. 标准库 功能性neterrorsossynctime 输入输出型iofmtlog 3. 版本控制 Git Go编程进阶原理 map channel goroutine slice runtime GMPGC √CGO反射测试 单元测试 压力测试 覆盖测试 性能测试 并发编程 goroutine调度 channel调度 锁 waitGroup context sync atomic 操作系统 数据结构与算法（熟练掌握）计算机原理与网络 缓存 数据库 设计模式 Linux 工程化微服务 Web框架 中间件","categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang学习路线","slug":"golang学习路线","permalink":"https://asonemaster.github.io/tags/golang%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}]}],"categories":[{"name":"go语言","slug":"go语言","permalink":"https://asonemaster.github.io/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"指针","slug":"指针","permalink":"https://asonemaster.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"结构体","slug":"结构体","permalink":"https://asonemaster.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"数组","slug":"数组","permalink":"https://asonemaster.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"切片","slug":"切片","permalink":"https://asonemaster.github.io/tags/%E5%88%87%E7%89%87/"},{"name":"golang学习路线","slug":"golang学习路线","permalink":"https://asonemaster.github.io/tags/golang%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}]}